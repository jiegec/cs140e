diff --git a/bootloader/.vscode/settings.json b/bootloader/.vscode/settings.json
index e69de29..2dd73f2 100644
--- a/bootloader/.vscode/settings.json
+++ b/bootloader/.vscode/settings.json
@@ -0,0 +1,4 @@
+{
+    "rust.target": "aarch64-none-elf",
+    "rust.sysroot": "/Users/macbookair/.xargo"
+}
\ No newline at end of file
diff --git a/bootloader/Xargo.toml b/bootloader/Xargo.toml
index 5e8c094..3fb0b62 100644
--- a/bootloader/Xargo.toml
+++ b/bootloader/Xargo.toml
@@ -1,6 +1,7 @@
 [dependencies]
 core = {}
 std_unicode = {}
+alloc = {}
 
 [dependencies.compiler_builtins]
 features = ["mem"]
diff --git a/bootloader/src/allocator b/bootloader/src/allocator
index e69de29..eb56ef6 120000
--- a/bootloader/src/allocator
+++ b/bootloader/src/allocator
@@ -0,0 +1 @@
+../../kernel/src/allocator
\ No newline at end of file
diff --git a/bootloader/src/console.rs b/bootloader/src/console.rs
index e69de29..9bf5d6e 120000
--- a/bootloader/src/console.rs
+++ b/bootloader/src/console.rs
@@ -0,0 +1 @@
+../../kernel/src/console.rs
\ No newline at end of file
diff --git a/bootloader/src/kmain.rs b/bootloader/src/kmain.rs
index 591a219..a3cbd2b 100644
--- a/bootloader/src/kmain.rs
+++ b/bootloader/src/kmain.rs
@@ -1,10 +1,30 @@
 #![feature(asm, lang_items)]
+#![feature(alloc, allocator_api, global_allocator)]
+#![feature(optin_builtin_traits)]
+#![feature(const_fn)]
+#![feature(decl_macro)]
+#![feature(core_intrinsics)]
 
-extern crate xmodem;
+extern crate alloc;
 extern crate pi;
+extern crate xmodem;
 
+use std::io;
+use std::io::Write;
+use pi::uart::MiniUart;
+
+pub mod mutex;
+pub mod console;
+pub mod allocator;
 pub mod lang_items;
 
+#[cfg(not(test))]
+use allocator::Allocator;
+
+#[cfg(not(test))]
+#[global_allocator]
+pub static ALLOCATOR: Allocator = Allocator::uninitialized();
+
 /// Start address of the binary to load and of the bootloader.
 const BINARY_START_ADDR: usize = 0x80000;
 const BOOTLOADER_START_ADDR: usize = 0x4000000;
@@ -19,11 +39,32 @@ const MAX_BINARY_SIZE: usize = BOOTLOADER_START_ADDR - BINARY_START_ADDR;
 fn jump_to(addr: *mut u8) -> ! {
     unsafe {
         asm!("br $0" : : "r"(addr as usize));
-        loop { asm!("nop" :::: "volatile")  }
+        loop {
+            asm!("nop" :::: "volatile")
+        }
     }
 }
 
 #[no_mangle]
 pub extern "C" fn kmain() {
     // FIXME: Implement the bootloader.
+    ALLOCATOR.initialize();
+    let mut uart = MiniUart::new();
+    uart.set_read_timeout(750);
+
+    loop {
+        let dest = unsafe { std::slice::from_raw_parts_mut(BINARY_START, MAX_BINARY_SIZE) };
+        match xmodem::Xmodem::receive(&mut uart, io::Cursor::new(dest)) {
+            Ok(_) => {
+                // Succeed
+                jump_to(BINARY_START)
+            }
+            Err(err) => match err.kind() {
+                io::ErrorKind::TimedOut => continue,
+                io::ErrorKind::InvalidData => continue, // might receive 0x00 when no input
+                _ => uart.write_fmt(format_args!("Error: {:?}\r\n", err))
+                    .unwrap(),
+            },
+        }
+    }
 }
diff --git a/bootloader/src/mutex.rs b/bootloader/src/mutex.rs
index e69de29..a29af40 120000
--- a/bootloader/src/mutex.rs
+++ b/bootloader/src/mutex.rs
@@ -0,0 +1 @@
+../../kernel/src/mutex.rs
\ No newline at end of file
diff --git a/kernel/.vscode/settings.json b/kernel/.vscode/settings.json
index e69de29..2dd73f2 100644
--- a/kernel/.vscode/settings.json
+++ b/kernel/.vscode/settings.json
@@ -0,0 +1,4 @@
+{
+    "rust.target": "aarch64-none-elf",
+    "rust.sysroot": "/Users/macbookair/.xargo"
+}
\ No newline at end of file
diff --git a/kernel/Cargo.toml b/kernel/Cargo.toml
index eadd84a..4f6690b 100644
--- a/kernel/Cargo.toml
+++ b/kernel/Cargo.toml
@@ -9,7 +9,6 @@ path = "src/kmain.rs"
 
 [profile.dev]
 panic = "abort"
-lto = true
 debug = true
 
 [profile.test]
diff --git a/kernel/Makefile b/kernel/Makefile
index 3572bad..be2aa78 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -3,7 +3,7 @@ CROSS ?= $(TARGET)
 
 CC := $(CROSS)-gcc
 TTYWRITE ?= ttywrite
-PI_TTY ?= /dev/tty.SLAB_USBtoUART
+PI_TTY ?= /dev/tty.SLAB_USBtoUART -b 230400
 CCFLAGS ?= -Wall -O2 -nostdlib -nostartfiles -ffreestanding -pie -fpie
 LDFLAGS ?= --gc-sections -static -nostdlib -nostartfiles --no-dynamic-linker
 XARGO ?= CARGO_INCREMENTAL=0 RUST_TARGET_PATH="$(shell pwd)" xargo
@@ -18,7 +18,7 @@ RUST_RELEASE_LIB := $(RUST_BUILD_DIR)/release/lib$(RUST_BINARY).a
 
 RUST_LIB_DEPS = ../pi/src/* ../pi/src/*/** \
 				../../1-shell/stack-vec/src/* \
-				../../2-fs/fat32/src/* ../../2-fs/fat32/src/*/**
+				../../2-fs/fat32/src/* ../../2-fs/fat32/src/*/** src/*/**
 
 RUST_DEPS = Xargo.toml Cargo.toml build.rs $(LD_LAYOUT) src/* $(RUST_LIB_DEPS)
 EXT_DEPS = $(BUILD_DIR)/init.o
diff --git a/kernel/ext/init.S b/kernel/ext/init.S
index 7941cd7..740a6e5 100644
--- a/kernel/ext/init.S
+++ b/kernel/ext/init.S
@@ -76,11 +76,16 @@ switch_to_el1:
 
     // set up exception handlers
     // FIXME: load `_vectors` addr into appropriate register (guide: 10.4)
+    adr     x2, _vectors
+    msr     VBAR_EL1, x2
 
     // change execution level to EL1 (ref: C5.2.19)
     mov     x2, #0x3c5
     msr     SPSR_EL2, x2
     // FIXME: Return to EL1 at `set_stack`.
+    adr     x2, set_stack
+    msr     ELR_EL2, x2
+    eret
 
 set_stack:
     // set the current stack pointer
@@ -105,11 +110,97 @@ go_kmain:
 
 context_save:
     // FIXME: Save the remaining context to the stack.
+    // naive way
+    stp     x29, lr, [SP, #-16]! // put current lr in reserved
+    stp     x27, x28, [SP, #-16]!
+    stp     x25, x26, [SP, #-16]!
+    stp     x23, x24, [SP, #-16]!
+    stp     x21, x22, [SP, #-16]!
+    stp     x19, x20, [SP, #-16]!
+    stp     x17, x18, [SP, #-16]!
+    stp     x15, x16, [SP, #-16]!
+    stp     x13, x14, [SP, #-16]!
+    stp     x11, x12, [SP, #-16]!
+    stp     x9, x10, [SP, #-16]!
+    stp     x7, x8, [SP, #-16]!
+    stp     x5, x6, [SP, #-16]!
+    stp     x3, x4, [SP, #-16]!
+    stp     x1, x2, [SP, #-16]!
+
+    stp     q30, q31, [SP, #-32]!
+    stp     q28, q29, [SP, #-32]!
+    stp     q26, q27, [SP, #-32]!
+    stp     q24, q25, [SP, #-32]!
+    stp     q22, q23, [SP, #-32]!
+    stp     q20, q21, [SP, #-32]!
+    stp     q18, q19, [SP, #-32]!
+    stp     q16, q17, [SP, #-32]!
+    stp     q14, q15, [SP, #-32]!
+    stp     q12, q13, [SP, #-32]!
+    stp     q10, q11, [SP, #-32]!
+    stp     q8, q9, [SP, #-32]!
+    stp     q6, q7, [SP, #-32]!
+    stp     q4, q5, [SP, #-32]!
+    stp     q2, q3, [SP, #-32]!
+    stp     q0, q1, [SP, #-32]!
+
+    mrs x2, TPIDR_EL0
+    mrs x1, SP_EL0
+    stp     x1, x2, [SP, #-16]!
+    mrs x2, SPSR_EL1
+    mrs x1, ELR_EL1
+    stp     x1, x2, [SP, #-16]!
+
+    mrs x1, ESR_EL1 // esr
+    mov x2, sp // tf is sp
+
+    mov x28, lr // save lr to a callee-saved register
+    bl handle_exception
+
+    mov lr, x28 // get current lr from r28.
 
 .global context_restore
 context_restore:
     // FIXME: Restore the context from the stack.
-
+    ldp     x1, x2, [SP], #16
+    msr ELR_EL1, x1
+    msr SPSR_EL1, x2
+    ldp     x1, x2, [SP], #16
+    msr SP_EL0, x1
+    msr TPIDR_EL0, x2
+
+    ldp     q0, q1, [SP], #32
+    ldp     q2, q3, [SP], #32
+    ldp     q4, q5, [SP], #32
+    ldp     q6, q7, [SP], #32
+    ldp     q8, q9, [SP], #32
+    ldp     q10, q11, [SP], #32
+    ldp     q12, q13, [SP], #32
+    ldp     q14, q15, [SP], #32
+    ldp     q16, q17, [SP], #32
+    ldp     q18, q19, [SP], #32
+    ldp     q20, q21, [SP], #32
+    ldp     q22, q23, [SP], #32
+    ldp     q24, q25, [SP], #32
+    ldp     q26, q27, [SP], #32
+    ldp     q28, q29, [SP], #32
+    ldp     q30, q31, [SP], #32
+
+    ldp     x1, x2, [SP], #16
+    ldp     x3, x4, [SP], #16
+    ldp     x5, x6, [SP], #16
+    ldp     x7, x8, [SP], #16
+    ldp     x9, x10, [SP], #16
+    ldp     x11, x12, [SP], #16
+    ldp     x13, x14, [SP], #16
+    ldp     x15, x16, [SP], #16
+    ldp     x17, x18, [SP], #16
+    ldp     x19, x20, [SP], #16
+    ldp     x21, x22, [SP], #16
+    ldp     x23, x24, [SP], #16
+    ldp     x25, x26, [SP], #16
+    ldp     x27, x28, [SP], #16
+    ldr     x29, [SP], #16
     ret
 
 #define HANDLER(source, kind) \
@@ -124,3 +215,19 @@ context_restore:
 .align 11
 _vectors:
     // FIXME: Setup the 16 exception vectors.
+    HANDLER(0,0)
+    HANDLER(0,1)
+    HANDLER(0,2)
+    HANDLER(0,3)
+    HANDLER(1,0)
+    HANDLER(1,1)
+    HANDLER(1,2)
+    HANDLER(1,3)
+    HANDLER(2,0)
+    HANDLER(2,1)
+    HANDLER(2,2)
+    HANDLER(2,3)
+    HANDLER(3,0)
+    HANDLER(3,1)
+    HANDLER(3,2)
+    HANDLER(3,3)
diff --git a/kernel/src/allocator/bin.rs b/kernel/src/allocator/bin.rs
index 5cde581..ff6c76a 100644
--- a/kernel/src/allocator/bin.rs
+++ b/kernel/src/allocator/bin.rs
@@ -1,19 +1,46 @@
+use std::cmp::max;
+use std::cmp::min;
 use std::fmt;
 use alloc::heap::{AllocErr, Layout};
 
 use allocator::util::*;
 use allocator::linked_list::LinkedList;
+use std::mem::size_of;
+
+const SIZEOF_USIZE: usize = size_of::<usize>();
 
 /// A simple allocator that allocates based on size classes.
 pub struct Allocator {
     // FIXME: Add the necessary fields.
+    // minimum=usize=8B, 2^3B
+    free_list: [LinkedList; 32],
+    allocated: usize,
+    total: usize,
 }
 
 impl Allocator {
     /// Creates a new bin allocator that will allocate memory from the region
     /// starting at address `start` and ending at address `end`.
     pub fn new(start: usize, end: usize) -> Allocator {
-        unimplemented!("bin allocator")
+        let mut free_list = [LinkedList::new(); 32];
+        let mut current_start = start;
+
+        let mut total = 0;
+        while current_start + SIZEOF_USIZE <= end {
+            let lowbit = current_start & (!current_start + 1);
+            let size = min(lowbit, prev_power_of_two(end - current_start));
+            total += size;
+            unsafe {
+                free_list[size.trailing_zeros() as usize].push(current_start as *mut usize);
+            }
+            current_start += size;
+        }
+
+        Allocator {
+            free_list: free_list,
+            allocated: 0,
+            total,
+        }
     }
 
     /// Allocates memory. Returns a pointer meeting the size and alignment
@@ -37,7 +64,32 @@ impl Allocator {
     /// (`AllocError::Exhausted`) or `layout` does not meet this allocator's
     /// size or alignment constraints (`AllocError::Unsupported`).
     pub fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {
-        unimplemented!("bin allocation")
+        let size = max(
+            layout.size().next_power_of_two(),
+            max(layout.align(), SIZEOF_USIZE),
+        );
+        let class = size.trailing_zeros() as usize;
+        for i in class..self.free_list.len() {
+            if !self.free_list[i].is_empty() {
+                for j in (class + 1..i + 1).rev() {
+                    let block = self.free_list[j]
+                        .pop()
+                        .expect("bigger block should have free space");
+                    unsafe {
+                        self.free_list[j - 1].push((block as usize + (1 << (j - 1))) as *mut usize);
+                        self.free_list[j - 1].push(block);
+                    }
+                }
+
+                let result = Ok(self.free_list[class]
+                    .pop()
+                    .expect("current block should have free space now")
+                    as *mut u8);
+                self.allocated += size;
+                return result;
+            }
+        }
+        Err(AllocErr::Exhausted { request: layout })
     }
 
     /// Deallocates the memory referenced by `ptr`.
@@ -54,8 +106,47 @@ impl Allocator {
     /// Parameters not meeting these conditions may result in undefined
     /// behavior.
     pub fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {
-        unimplemented!("bin deallocation")
+        let size = max(
+            layout.size().next_power_of_two(),
+            max(layout.align(), SIZEOF_USIZE),
+        );
+        let class = size.trailing_zeros() as usize;
+
+        unsafe {
+            self.free_list[class].push(ptr as *mut usize);
+            let mut current_ptr = ptr as usize;
+            let mut current_class = class;
+            loop {
+                let buddy = current_ptr ^ (1 << current_class);
+                let mut flag = false;
+                for block in self.free_list[current_class].iter_mut() {
+                    if block.value() as usize == buddy {
+                        block.pop();
+                        flag = true;
+                        break;
+                    }
+                }
+                if flag {
+                    self.free_list[current_class].pop();
+                    current_ptr = min(current_ptr, buddy);
+                    current_class += 1;
+                    self.free_list[current_class].push(current_ptr as *mut usize);
+                } else {
+                    break;
+                }
+            }
+        }
+
+        self.allocated -= size;
     }
 }
 
 // FIXME: Implement `Debug` for `Allocator`.
+impl fmt::Debug for Allocator {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("BinAllocator")
+            .field("allocated", &self.allocated)
+            .field("total", &self.total)
+            .finish()
+    }
+}
diff --git a/kernel/src/allocator/bump.rs b/kernel/src/allocator/bump.rs
index e8741cf..02ae36e 100644
--- a/kernel/src/allocator/bump.rs
+++ b/kernel/src/allocator/bump.rs
@@ -13,7 +13,10 @@ impl Allocator {
     /// Creates a new bump allocator that will allocate memory from the region
     /// starting at address `start` and ending at address `end`.
     pub fn new(start: usize, end: usize) -> Allocator {
-        unimplemented!("bump allocator")
+        Allocator {
+            current: start,
+            end: end,
+        }
     }
 
     /// Allocates memory. Returns a pointer meeting the size and alignment
@@ -37,7 +40,14 @@ impl Allocator {
     /// (`AllocError::Exhausted`) or `layout` does not meet this allocator's
     /// size or alignment constraints (`AllocError::Unsupported`).
     pub fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {
-        unimplemented!("bump allocation")
+        let new_start = align_up(self.current, layout.align()).saturating_add(layout.size());
+
+        if new_start >= self.end {
+            return Err(AllocErr::Exhausted { request: layout });
+        }
+
+        self.current = new_start;
+        Ok((new_start - layout.size()) as *mut u8)
     }
 
     /// Deallocates the memory referenced by `ptr`.
@@ -54,6 +64,6 @@ impl Allocator {
     /// Parameters not meeting these conditions may result in undefined
     /// behavior.
     pub fn dealloc(&mut self, _ptr: *mut u8, _layout: Layout) {
-        unimplemented!("bump deallocation")
+        // Do nothing
     }
 }
diff --git a/kernel/src/allocator/mod.rs b/kernel/src/allocator/mod.rs
index f82206d..5d3c145 100644
--- a/kernel/src/allocator/mod.rs
+++ b/kernel/src/allocator/mod.rs
@@ -1,7 +1,7 @@
 mod linked_list;
 mod util;
 
-#[path = "bump.rs"]
+#[path = "bin.rs"]
 mod imp;
 
 #[cfg(test)]
@@ -10,6 +10,7 @@ mod tests;
 use mutex::Mutex;
 use alloc::heap::{Alloc, AllocErr, Layout};
 use std::cmp::max;
+use pi::atags::Atags;
 
 /// Thread-safe (locking) wrapper around a particular memory allocator.
 #[derive(Debug)]
@@ -57,7 +58,11 @@ unsafe impl<'a> Alloc for &'a Allocator {
     /// (`AllocError::Exhausted`) or `layout` does not meet this allocator's
     /// size or alignment constraints (`AllocError::Unsupported`).
     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {
-        self.0.lock().as_mut().expect("allocator uninitialized").alloc(layout)
+        self.0
+            .lock()
+            .as_mut()
+            .expect("allocator uninitialized")
+            .alloc(layout)
     }
 
     /// Deallocates the memory referenced by `ptr`.
@@ -74,7 +79,11 @@ unsafe impl<'a> Alloc for &'a Allocator {
     /// Parameters not meeting these conditions may result in undefined
     /// behavior.
     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {
-        self.0.lock().as_mut().expect("allocator uninitialized").dealloc(ptr, layout);
+        self.0
+            .lock()
+            .as_mut()
+            .expect("allocator uninitialized")
+            .dealloc(ptr, layout);
     }
 }
 
@@ -87,7 +96,21 @@ extern "C" {
 ///
 /// This function is expected to return `Some` under all normal cirumstances.
 fn memory_map() -> Option<(usize, usize)> {
-    let binary_end = unsafe { (&_end as *const u8) as u32 };
+    let binary_end = unsafe { (&_end as *const u8) as usize };
 
-    unimplemented!("memory map fetch")
+    for tag in Atags::get() {
+        match tag.mem() {
+            Some(mem) => {
+                let mut start = mem.start as usize;
+                let end = (mem.start + mem.size) as usize;
+                if binary_end < end {
+                    start = max(start, binary_end);
+                }
+                return Some((start, end));
+            }
+            _ => {}
+        }
+    }
+
+    None
 }
diff --git a/kernel/src/allocator/util.rs b/kernel/src/allocator/util.rs
index 11e0477..9e5c552 100644
--- a/kernel/src/allocator/util.rs
+++ b/kernel/src/allocator/util.rs
@@ -1,3 +1,7 @@
+#![allow(dead_code)]
+
+use std::mem::size_of;
+
 /// Align `addr` downwards to the nearest multiple of `align`.
 ///
 /// The returned usize is always <= `addr.`
@@ -6,7 +10,11 @@
 ///
 /// Panics if `align` is not a power of 2.
 pub fn align_down(addr: usize, align: usize) -> usize {
-    unimplemented!()
+    if !align.is_power_of_two() {
+        panic!("align_down: align not a power of 2");
+    }
+
+    addr & !(align - 1)
 }
 
 /// Align `addr` upwards to the nearest multiple of `align`.
@@ -17,5 +25,9 @@ pub fn align_down(addr: usize, align: usize) -> usize {
 ///
 /// Panics if `align` is not a power of 2.
 pub fn align_up(addr: usize, align: usize) -> usize {
-    unimplemented!()
+    align_down(addr.saturating_add(align - 1), align)
 }
+
+pub fn prev_power_of_two(num: usize) -> usize {
+    1 << (8 * (size_of::<usize>()) - num.leading_zeros() as usize - 1)
+}
\ No newline at end of file
diff --git a/kernel/src/console.rs b/kernel/src/console.rs
index e0f18f9..35609c1 100644
--- a/kernel/src/console.rs
+++ b/kernel/src/console.rs
@@ -7,7 +7,7 @@ use mutex::Mutex;
 
 /// A global singleton allowing read/write access to the console.
 pub struct Console {
-    inner: Option<MiniUart>
+    inner: Option<MiniUart>,
 }
 
 impl Console {
@@ -19,35 +19,36 @@ impl Console {
     /// Initializes the console if it's not already initialized.
     #[inline]
     fn initialize(&mut self) {
-        unimplemented!()
+        self.inner.get_or_insert_with(&MiniUart::new);
     }
 
     /// Returns a mutable borrow to the inner `MiniUart`, initializing it as
     /// needed.
     fn inner(&mut self) -> &mut MiniUart {
-        unimplemented!()
+        self.initialize();
+        self.inner.as_mut().unwrap()
     }
 
     /// Reads a byte from the UART device, blocking until a byte is available.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        self.inner().read_byte()
     }
 
     /// Writes the byte `byte` to the UART device.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        self.inner().write_byte(byte)
     }
 }
 
 impl io::Read for Console {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().read(buf)
     }
 }
 
 impl io::Write for Console {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().write(buf)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -57,7 +58,7 @@ impl io::Write for Console {
 
 impl fmt::Write for Console {
     fn write_str(&mut self, s: &str) -> fmt::Result {
-        unimplemented!()
+        self.inner().write_str(s)
     }
 }
 
@@ -89,3 +90,23 @@ pub macro kprintln {
 pub macro kprint($($arg:tt)*) {
     _print(format_args!($($arg)*))
 }
+
+/// Internal function called by the `noblock_kprint[ln]!` macros.
+#[doc(hidden)]
+pub fn _noblock_print(args: fmt::Arguments) {
+    use std::fmt::Write;
+    let mut console = Console::new();
+    console.write_fmt(args).unwrap();
+}
+
+/// Like `println!`, but non-blocking and for kernel-space.
+pub macro noblock_kprintln {
+    () => (noblock_kprint!("\n")),
+    ($fmt:expr) => (noblock_kprint!(concat!($fmt, "\n"))),
+    ($fmt:expr, $($arg:tt)*) => (noblock_kprint!(concat!($fmt, "\n"), $($arg)*))
+}
+
+/// Like `print!`, but non-blocking and for kernel-space.
+pub macro noblock_kprint($($arg:tt)*) {
+    _noblock_print(format_args!($($arg)*))
+}
diff --git a/kernel/src/fs/mod.rs b/kernel/src/fs/mod.rs
index 593bb50..7cda8af 100644
--- a/kernel/src/fs/mod.rs
+++ b/kernel/src/fs/mod.rs
@@ -1,14 +1,15 @@
 pub mod sd;
 
 use std::io;
-use std::path::Path;
+use std::path::{Path, PathBuf};
 
-use fat32::vfat::{self, Shared, VFat};
+use fat32::vfat::{Shared, VFat};
 pub use fat32::traits;
 
 use mutex::Mutex;
 use self::sd::Sd;
 
+#[derive(Debug)]
 pub struct FileSystem(Mutex<Option<Shared<VFat>>>);
 
 impl FileSystem {
@@ -26,8 +27,44 @@ impl FileSystem {
     ///
     /// Panics if the underlying disk or file sytem failed to initialize.
     pub fn initialize(&self) {
-        unimplemented!("FileSystem::initialize()")
+        *self.0.lock() = Some(VFat::from(Sd::new().unwrap()).unwrap());
     }
 }
 
 // FIXME: Implement `fat32::traits::FileSystem` for a useful type.
+impl<'a> traits::FileSystem for &'a FileSystem {
+    type File = <&'a Shared<VFat> as traits::FileSystem>::File;
+    type Dir = <&'a Shared<VFat> as traits::FileSystem>::Dir;
+    type Entry = <&'a Shared<VFat> as traits::FileSystem>::Entry;
+
+    fn open<P: AsRef<Path>>(self, path: P) -> io::Result<Self::Entry> {
+        self.0.lock().as_ref().unwrap().open(path)
+    }
+
+    fn canonicalize<P: AsRef<Path>>(self, path: P) -> io::Result<PathBuf> {
+        self.0.lock().as_ref().unwrap().canonicalize(path)
+    }
+
+    fn create_file<P: AsRef<Path>>(self, path: P) -> io::Result<Self::File> {
+        self.0.lock().as_ref().unwrap().create_file(path)
+    }
+
+    fn create_dir<P>(self, path: P, parents: bool) -> io::Result<Self::Dir>
+    where
+        P: AsRef<Path>,
+    {
+        self.0.lock().as_ref().unwrap().create_dir(path, parents)
+    }
+
+    fn rename<P, Q>(self, from: P, to: Q) -> io::Result<()>
+    where
+        P: AsRef<Path>,
+        Q: AsRef<Path>,
+    {
+        self.0.lock().as_ref().unwrap().rename(from, to)
+    }
+
+    fn remove<P: AsRef<Path>>(self, path: P, children: bool) -> io::Result<()> {
+        self.0.lock().as_ref().unwrap().remove(path, children)
+    }
+}
diff --git a/kernel/src/fs/sd.rs b/kernel/src/fs/sd.rs
index 0eb2632..0a59d14 100644
--- a/kernel/src/fs/sd.rs
+++ b/kernel/src/fs/sd.rs
@@ -1,3 +1,4 @@
+use pi::timer::spin_sleep_us;
 use std::io;
 use fat32::traits::BlockDevice;
 
@@ -28,19 +29,54 @@ extern "C" {
 // FIXME: Define a `#[no_mangle]` `wait_micros` function for use by `libsd`.
 // The `wait_micros` C signature is: `void wait_micros(unsigned int);`
 
+#[no_mangle]
+pub extern "C" fn wait_micros(micros: u32) {
+    spin_sleep_us((micros * 100).into());
+}
+
 #[derive(Debug)]
 pub enum Error {
     // FIXME: Fill me in.
+    TimedOut,
+    SendingCommandFailed,
+    UnknownError(i64),
 }
 
 /// A handle to an SD card controller.
 #[derive(Debug)]
 pub struct Sd;
 
+impl From<Error> for io::Error {
+    fn from(err: Error) -> io::Error {
+        match err {
+            Error::TimedOut => {
+                io::Error::new(io::ErrorKind::TimedOut, "SD card operation timed out")
+            }
+            Error::SendingCommandFailed => io::Error::new(
+                io::ErrorKind::Other,
+                "Sending command to SD card controller failed",
+            ),
+            Error::UnknownError(err) => io::Error::new(
+                io::ErrorKind::Other,
+                format!("Got unknown card error: {}", err),
+            ),
+        }
+    }
+}
+
 impl Sd {
     /// Initializes the SD card controller and returns a handle to it.
     pub fn new() -> Result<Sd, Error> {
-        unimplemented!("Sd::new()")
+        let result = unsafe { sd_init() };
+        if result == 0 {
+            Ok(Sd {})
+        } else if result == -1 {
+            Err(Error::TimedOut)
+        } else if result == -2 {
+            Err(Error::SendingCommandFailed)
+        } else {
+            Err(Error::UnknownError(unsafe { sd_err }))
+        }
     }
 }
 
@@ -58,7 +94,25 @@ impl BlockDevice for Sd {
     ///
     /// An error of kind `Other` is returned for all other errors.
     fn read_sector(&mut self, n: u64, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!("Sd::read_sector()")
+        if buf.len() < 512 || n > 0x7FFFFFFF {
+            return Err(io::Error::new(
+                io::ErrorKind::InvalidInput,
+                "read_sector received wrong parameter",
+            ));
+        }
+        let result = unsafe { sd_readsector(n as i32, buf.as_mut_ptr()) };
+        if result > 0 {
+            Ok(result as usize)
+        } else {
+            let errno = unsafe { sd_err };
+            if errno == -1 {
+                Err(Error::TimedOut.into())
+            } else if errno == -2 {
+                Err(Error::SendingCommandFailed.into())
+            } else {
+                Err(Error::UnknownError(errno).into())
+            }
+        }
     }
 
     fn write_sector(&mut self, _n: u64, _buf: &[u8]) -> io::Result<usize> {
diff --git a/kernel/src/kmain.rs b/kernel/src/kmain.rs
index e9522cd..db26f88 100644
--- a/kernel/src/kmain.rs
+++ b/kernel/src/kmain.rs
@@ -4,7 +4,6 @@
 #![feature(asm)]
 #![feature(optin_builtin_traits)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(exclusive_range_pattern)]
 #![feature(i128_type)]
@@ -14,15 +13,22 @@
 #![feature(naked_functions)]
 #![feature(fn_must_use)]
 #![feature(alloc, allocator_api, global_allocator)]
+#![feature(ptr_internals)]
 
 #[macro_use]
 #[allow(unused_imports)]
 extern crate alloc;
+extern crate fat32;
 extern crate pi;
 extern crate stack_vec;
-extern crate fat32;
 
 pub mod allocator;
+use pi::gpio::Gpio;
+use std::fmt::Write;
+use pi::uart::MiniUart;
+use pi::timer::spin_sleep_ms;
+use pi::timer::current_time;
+
 pub mod lang_items;
 pub mod mutex;
 pub mod console;
@@ -50,4 +56,19 @@ pub static SCHEDULER: GlobalScheduler = GlobalScheduler::uninitialized();
 #[cfg(not(test))]
 pub extern "C" fn kmain() {
     ALLOCATOR.initialize();
+    FILE_SYSTEM.initialize();
+    spin_sleep_ms(200);
+    SCHEDULER.start();
+}
+
+pub extern "C" fn shell_thread() {
+    loop {
+        shell::shell("$ ");
+    }
+}
+
+pub extern "C" fn shell_thread_2() {
+    loop {
+        // shell::shell("# ");
+    }
 }
diff --git a/kernel/src/lang_items.rs b/kernel/src/lang_items.rs
index 3a1e46f..83848e3 100644
--- a/kernel/src/lang_items.rs
+++ b/kernel/src/lang_items.rs
@@ -3,8 +3,15 @@
 #[lang = "panic_fmt"]
 pub extern fn panic_fmt(fmt: ::std::fmt::Arguments, file: &'static str, line: u32, col: u32) -> ! {
     // FIXME: Print `fmt`, `file`, and `line` to the console.
+    // Avoid deadlock
+    use console::noblock_kprintln;
+    noblock_kprintln!("Kernel Panic at file {}\n\t\tline {}, col {}: {}", file, line, col, fmt);
 
-    loop { unsafe { asm!("wfe") } }
+    loop {
+        unsafe { asm!("wfe") }
+    }
 }
 
-#[cfg(not(test))] #[lang = "eh_personality"] pub extern fn eh_personality() {}
+#[cfg(not(test))]
+#[lang = "eh_personality"]
+pub extern "C" fn eh_personality() {}
diff --git a/kernel/src/mutex.rs b/kernel/src/mutex.rs
index 79fba5f..16913c2 100644
--- a/kernel/src/mutex.rs
+++ b/kernel/src/mutex.rs
@@ -1,7 +1,7 @@
 use std::sync::atomic::{AtomicBool, AtomicUsize};
 use std::sync::atomic::Ordering::Relaxed;
 use std::cell::UnsafeCell;
-use std::ops::{DerefMut, Deref, Drop};
+use std::ops::{Deref, DerefMut, Drop};
 use std::fmt;
 
 #[repr(align(32))]
@@ -11,22 +11,22 @@ pub struct Mutex<T> {
     owner: AtomicUsize
 }
 
-unsafe impl<T: Send> Send for Mutex<T> { }
-unsafe impl<T: Send> Sync for Mutex<T> { }
+unsafe impl<T: Send> Send for Mutex<T> {}
+unsafe impl<T: Send> Sync for Mutex<T> {}
 
 pub struct MutexGuard<'a, T: 'a> {
-    lock: &'a Mutex<T>
+    lock: &'a Mutex<T>,
 }
 
-impl<'a, T> !Send for MutexGuard<'a, T> { }
-unsafe impl<'a, T: Sync> Sync for MutexGuard<'a, T> { }
+impl<'a, T> !Send for MutexGuard<'a, T> {}
+unsafe impl<'a, T: Sync> Sync for MutexGuard<'a, T> {}
 
 impl<T> Mutex<T> {
     pub const fn new(val: T) -> Mutex<T> {
         Mutex {
             lock: AtomicBool::new(false),
             owner: AtomicUsize::new(usize::max_value()),
-            data: UnsafeCell::new(val)
+            data: UnsafeCell::new(val),
         }
     }
 }
@@ -53,7 +53,7 @@ impl<T> Mutex<T> {
         loop {
             match self.try_lock() {
                 Some(guard) => return guard,
-                None => continue
+                None => continue,
             }
         }
     }
@@ -67,7 +67,7 @@ impl<'a, T: 'a> Deref for MutexGuard<'a, T> {
     type Target = T;
 
     fn deref(&self) -> &T {
-        unsafe { & *self.lock.data.get() }
+        unsafe { &*self.lock.data.get() }
     }
 }
 
@@ -87,7 +87,7 @@ impl<T: fmt::Debug> fmt::Debug for Mutex<T> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self.try_lock() {
             Some(guard) => f.debug_struct("Mutex").field("data", &&*guard).finish(),
-            None => f.debug_struct("Mutex").field("data", &"<locked>").finish()
+            None => f.debug_struct("Mutex").field("data", &"<locked>").finish(),
         }
     }
 }
diff --git a/kernel/src/process/process.rs b/kernel/src/process/process.rs
index 3bf9b70..b7f69a9 100644
--- a/kernel/src/process/process.rs
+++ b/kernel/src/process/process.rs
@@ -1,5 +1,6 @@
 use traps::TrapFrame;
-use process::{State, Stack};
+use process::{Stack, State};
+use std::mem::replace;
 
 /// Type alias for the type of a process ID.
 pub type Id = u64;
@@ -22,7 +23,14 @@ impl Process {
     /// If enough memory could not be allocated to start the process, returns
     /// `None`. Otherwise returns `Some` of the new `Process`.
     pub fn new() -> Option<Process> {
-        unimplemented!("Process::new()")
+        match Stack::new() {
+            Some(stack) => Some(Process {
+                trap_frame: Box::new(TrapFrame::default()),
+                stack,
+                state: State::Ready,
+            }),
+            None => None,
+        }
     }
 
     /// Returns `true` if this process is ready to be scheduled.
@@ -40,6 +48,22 @@ impl Process {
     ///
     /// Returns `false` in all other cases.
     pub fn is_ready(&mut self) -> bool {
-        unimplemented!("Process::is_ready()")
+        if let State::Ready = self.state {
+            true
+        } else if let State::Running = self.state {
+            false
+        } else {
+            let state = replace(&mut self.state, State::Ready);
+            if let State::Waiting(mut event_poll_fn) = state {
+                if event_poll_fn(self) {
+                    true
+                } else {
+                    self.state = State::Waiting(event_poll_fn);
+                    false
+                }
+            } else {
+                unreachable!();
+            }
+        }
     }
 }
diff --git a/kernel/src/process/scheduler.rs b/kernel/src/process/scheduler.rs
index 669b464..c99652b 100644
--- a/kernel/src/process/scheduler.rs
+++ b/kernel/src/process/scheduler.rs
@@ -1,12 +1,17 @@
 use std::collections::VecDeque;
 
 use mutex::Mutex;
-use process::{Process, State, Id};
+use process::{Id, Process, State};
 use traps::TrapFrame;
+use shell_thread;
+use shell_thread_2;
+use pi::interrupt::{Controller, Interrupt};
+use pi::timer::tick_in;
 
 /// The `tick` time.
 // FIXME: When you're ready, change this to something more reasonable.
-pub const TICK: u32 = 2 * 1000 * 1000;
+// pub const TICK: u32 = 2 * 1000 * 1000;
+pub const TICK: u32 = 10 * 1000; // 10ms
 
 /// Process scheduler for the entire machine.
 #[derive(Debug)]
@@ -21,7 +26,11 @@ impl GlobalScheduler {
     /// Adds a process to the scheduler's queue and returns that process's ID.
     /// For more details, see the documentation on `Scheduler::add()`.
     pub fn add(&self, process: Process) -> Option<Id> {
-        self.0.lock().as_mut().expect("scheduler uninitialized").add(process)
+        self.0
+            .lock()
+            .as_mut()
+            .expect("scheduler uninitialized")
+            .add(process)
     }
 
     /// Performs a context switch using `tf` by setting the state of the current
@@ -30,14 +39,42 @@ impl GlobalScheduler {
     /// the documentation on `Scheduler::switch()`.
     #[must_use]
     pub fn switch(&self, new_state: State, tf: &mut TrapFrame) -> Option<Id> {
-        self.0.lock().as_mut().expect("scheduler uninitialized").switch(new_state, tf)
+        self.0
+            .lock()
+            .as_mut()
+            .expect("scheduler uninitialized")
+            .switch(new_state, tf)
     }
 
     /// Initializes the scheduler and starts executing processes in user space
     /// using timer interrupt based preemptive scheduling. This method should
     /// not return under normal conditions.
     pub fn start(&self) {
-        unimplemented!("GlobalScheduler::start()")
+        let mut scheduler = Scheduler::new();
+        Controller::new().enable(Interrupt::Timer1);
+        tick_in(TICK);
+
+        let mut process = Process::new().unwrap();
+        process.trap_frame.sp = process.stack.top().as_u64();
+        process.trap_frame.elr = shell_thread as *mut u8 as u64;
+        process.trap_frame.spsr = 0b1101_00_0000; // To EL 0, currently only unmasking IRQ
+        scheduler.add(process).unwrap();
+
+        let mut process2 = Process::new().unwrap();
+        process2.trap_frame.sp = process2.stack.top().as_u64();
+        process2.trap_frame.elr = shell_thread_2 as *mut u8 as u64;
+        process2.trap_frame.spsr = 0b1101_00_0000; // To EL 0, currently only unmasking IRQ
+        scheduler.add(process2).unwrap();
+
+        *self.0.lock() = Some(scheduler);
+        unsafe {
+            asm!("mov sp, $0
+              bl context_restore
+              adr lr, _start
+              mov sp, lr
+              mov lr, xzr
+              eret" :: "r"(&*(self.0.lock().as_mut().unwrap()).processes[0].trap_frame) :: "volatile");
+        };
     }
 }
 
@@ -51,7 +88,11 @@ struct Scheduler {
 impl Scheduler {
     /// Returns a new `Scheduler` with an empty queue.
     fn new() -> Scheduler {
-        unimplemented!("Scheduler::new()")
+        Scheduler {
+            processes: VecDeque::new(),
+            current: None,
+            last_id: None,
+        }
     }
 
     /// Adds a process to the scheduler's queue and returns that process's ID if
@@ -63,7 +104,18 @@ impl Scheduler {
     /// It is the caller's responsibility to ensure that the first time `switch`
     /// is called, that process is executing on the CPU.
     fn add(&mut self, mut process: Process) -> Option<Id> {
-        unimplemented!("Scheduler::add()")
+        let id = self.last_id.get_or_insert(0);
+
+        // FIXME: handle overflow
+        *id += 1;
+        process.trap_frame.tpidr = *id;
+        self.processes.push_back(process);
+
+        if let None = self.current {
+            self.current = Some(*id);
+        }
+
+        Some(*id)
     }
 
     /// Sets the current process's state to `new_state`, finds the next process
@@ -75,6 +127,30 @@ impl Scheduler {
     /// This method blocks until there is a process to switch to, conserving
     /// energy as much as possible in the interim.
     fn switch(&mut self, new_state: State, tf: &mut TrapFrame) -> Option<Id> {
-        unimplemented!("Scheduler::switch()")
+        if self.current != Some(tf.tpidr) {
+            return None;
+        }
+
+        let mut process = self.processes.pop_front().unwrap();
+        process.state = new_state;
+        *process.trap_frame = *tf;
+        self.processes.push_back(process);
+
+        loop {
+            let num_processes = self.processes.len();
+            for _ in 0..num_processes {
+                let mut new_process = self.processes.pop_front().unwrap();
+                if new_process.is_ready() {
+                    *tf = *new_process.trap_frame;
+                    new_process.state = State::Running;
+                    self.current = Some(tf.tpidr);
+                    self.processes.push_front(new_process);
+                    return self.current;
+                } else {
+                    self.processes.push_back(new_process);
+                }
+            }
+            unsafe { asm!("wfi") }
+        }
     }
 }
diff --git a/kernel/src/shell.rs b/kernel/src/shell.rs
index a3ad171..d7d15ea 100644
--- a/kernel/src/shell.rs
+++ b/kernel/src/shell.rs
@@ -1,16 +1,46 @@
-use stack_vec::StackVec;
 use console::{kprint, kprintln, CONSOLE};
+use std::path::{Path, PathBuf};
+use pi::timer::{current_time, spin_sleep_ms};
+use pi::gpio::Gpio;
+use pi::atags::Atags;
+#[cfg(not(test))]
+use ALLOCATOR;
+use FILE_SYSTEM;
+use fat32::traits::{Dir, Entry, File, FileSystem, Metadata};
+use std::io::Read;
+use std::str;
+use aarch64;
 
 /// Error type for `Command` parse failures.
 #[derive(Debug)]
 enum Error {
     Empty,
-    TooManyArgs
 }
 
+const BEL: u8 = 0x07u8;
+const BS: u8 = 0x08u8;
+const LF: u8 = 0x0au8;
+const CR: u8 = 0x0du8;
+const ESC: u8 = 0x1bu8;
+const DEL: u8 = 0x7fu8;
+
+const BANNER: &str = r#"
+                 _ _ ___         
+             __-         `-_    
+         ___/__        ã€‡   \ 
+     - '     _/             /
+   '_'             /
+ / _- ---            __ -
+/`     |          _ / \  \
+       |       -       \ |
+        \    /          V
+          \  |
+            \ \
+              \"#;
+
 /// A structure representing a single shell command.
 struct Command<'a> {
-    args: StackVec<'a, &'a str>
+    args: Vec<&'a str>,
 }
 
 impl<'a> Command<'a> {
@@ -21,10 +51,10 @@ impl<'a> Command<'a> {
     ///
     /// If `s` contains no arguments, returns `Error::Empty`. If there are more
     /// arguments than `buf` can hold, returns `Error::TooManyArgs`.
-    fn parse(s: &'a str, buf: &'a mut [&'a str]) -> Result<Command<'a>, Error> {
-        let mut args = StackVec::new(buf);
+    fn parse(s: &str) -> Result<Command, Error> {
+        let mut args = Vec::with_capacity(64);
         for arg in s.split(' ').filter(|a| !a.is_empty()) {
-            args.push(arg).map_err(|_| Error::TooManyArgs)?;
+            args.push(arg);
         }
 
         if args.is_empty() {
@@ -36,12 +66,406 @@ impl<'a> Command<'a> {
 
     /// Returns this command's path. This is equivalent to the first argument.
     fn path(&self) -> &str {
-        unimplemented!()
+        self.args[0]
     }
 }
 
 /// Starts a shell using `prefix` as the prefix for each line. This function
 /// returns if the `exit` command is called.
 pub fn shell(prefix: &str) {
-    unimplemented!()
+    spin_sleep_ms(200); // wait a little time for client to attach
+    kprintln!("{}", BANNER);
+
+    let mut history = Vec::new();
+    let mut cwd = PathBuf::from("/");
+    loop {
+        kprint!("{}{}", cwd.display(), prefix);
+
+        let line = read_line(&mut history);
+        match Command::parse(&line) {
+            Ok(command) => {
+                let path = command.path();
+                match path {
+                    "atags" => atags(&command),
+                    "brk" => brk(),
+                    "cat" => cat(&command, cwd.as_path()),
+                    "cd" => cwd = cd(&command, cwd),
+                    "current_el" => current_el(),
+                    "echo" => echo(&command),
+                    "echohex" => echohex(&command),
+                    "exit" => return,
+                    "gpio" => gpio(&command),
+                    "ls" => ls(&command, cwd.as_path()),
+                    "memstat" => memstat(&command),
+                    "panic" => panic(&command),
+                    "pwd" => pwd(&command, cwd.as_path()),
+                    "sleep" => sleep(&command),
+                    "uptime" => uptime(&command),
+                    _ => kprintln!("unknown command: {}", path),
+                }
+            }
+            Err(Error::Empty) => {
+                // Ignore
+            }
+        }
+    }
+}
+
+fn read_line(history: &mut Vec<Vec<u8>>) -> String {
+    let mut console = CONSOLE.lock();
+    let mut cursor = 0;
+    let mut line_vec = Vec::with_capacity(512);
+    let mut history_index = history.len();
+    loop {
+        match console.read_byte() {
+            BS | DEL => {
+                // Backspace
+                if cursor > 0 {
+                    cursor -= 1;
+                    line_vec.remove(cursor);
+
+                    console.write_byte(BS);
+                    for byte in &line_vec[cursor..] {
+                        console.write_byte(*byte);
+                    }
+                    console.write_byte(b' ');
+                    for _i in cursor..line_vec.len() {
+                        console.write_byte(BS);
+                    }
+                    console.write_byte(BS);
+                } else {
+                    console.write_byte(BEL);
+                }
+            }
+            CR | LF => {
+                // Return
+                console.write_byte(CR);
+                console.write_byte(LF);
+                break;
+            }
+            ESC => {
+                match console.read_byte() {
+                    b'[' => {
+                        match console.read_byte() {
+                            b'D' => {
+                                // Left arrow
+                                if cursor > 0 {
+                                    cursor -= 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'D');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            b'C' => {
+                                // Right arrow
+                                if cursor < line_vec.len() {
+                                    cursor += 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'C');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            direction @ b'A' | direction @ b'B' => {
+                                if direction == b'A' && history_index > 0 {
+                                    // Up arrow
+                                    history_index -= 1;
+                                } else if direction == b'B' && history.len() > 0 // usize underflow
+                                    && history_index < history.len() - 1
+                                {
+                                    // Down arrow
+                                    history_index += 1;
+                                } else {
+                                    console.write_byte(BEL);
+                                    continue;
+                                }
+
+                                for _ in 0..line_vec.len() {
+                                    console.write_byte(BS);
+                                }
+                                for _ in 0..line_vec.len() {
+                                    console.write_byte(b' ');
+                                }
+                                for _ in 0..line_vec.len() {
+                                    console.write_byte(BS);
+                                }
+                                line_vec = history[history_index].clone();
+                                cursor = line_vec.len();
+                                for byte in &line_vec {
+                                    console.write_byte(*byte);
+                                }
+                            }
+                            _ => {
+                                console.write_byte(BEL);
+                            }
+                        }
+                    }
+                    _ => {
+                        console.write_byte(BEL);
+                    }
+                }
+            }
+            byte if byte.is_ascii_graphic() || byte == b' ' => {
+                line_vec.insert(cursor, byte);
+                for byte in &line_vec[cursor..] {
+                    console.write_byte(*byte);
+                }
+                cursor += 1;
+                for _i in cursor..line_vec.len() {
+                    console.write_byte(BS);
+                }
+            }
+            _ => {
+                // unrecognized characters
+                console.write_byte(BEL);
+            }
+        }
+    }
+
+    history.push(line_vec.clone());
+    String::from_utf8(line_vec).unwrap_or_default()
+}
+
+fn echo(command: &Command) {
+    if command.args.len() > 1 {
+        kprint!("{}", command.args[1]);
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" {}", *arg);
+            }
+        }
+    }
+
+    kprintln!();
+}
+
+fn echohex(command: &Command) {
+    echo(&command);
+    if command.args.len() > 1 {
+        for byte in command.args[1].bytes() {
+            kprint!("{:02X}", byte);
+        }
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" ");
+                for byte in arg.bytes() {
+                    kprint!("{:02X}", byte);
+                }
+            }
+        }
+    }
+
+    kprintln!();
+}
+
+fn uptime(_command: &Command) {
+    let time = current_time();
+    let sec = time / 1000 / 1000;
+    let min = sec / 60;
+    let hour = min / 60;
+    let day = hour / 24;
+    kprintln!(
+        "Uptime: {} day(s), {:02}:{:02}:{:02}",
+        day,
+        hour % 24,
+        min % 60,
+        sec % 60
+    );
+}
+
+/*
+fn exit(_command: &Command) -> ! {
+    kprintln!(
+        "Might be dangerous: bootloader might be corrupted, especially when using bin allocator."
+    );
+    kprintln!("Now exiting to bootloader. Detach and send a new kernel to continue.");
+    // in line with bootloader
+    const BOOTLOADER_START_ADDR: usize = 0x4000000;
+    unsafe {
+        asm!("br $0" : : "r"(BOOTLOADER_START_ADDR));
+        loop {
+            asm!("nop" :::: "volatile")
+        }
+    }
+}
+*/
+
+fn panic(_command: &Command) -> ! {
+    panic!("You ask me to panic!");
+}
+
+fn atags(_command: &Command) {
+    for atag in Atags::get() {
+        kprintln!("{:?}", atag);
+    }
 }
+
+fn memstat(_command: &Command) {
+    #[cfg(not(test))]
+    kprintln!("Allocator: {:?}", ALLOCATOR);
+}
+
+fn ls(command: &Command, cwd: &Path) {
+    let (all, path) = if command.args.len() > 3 {
+        kprintln!("Wrong number of args! Usage: ls [-a] [directory]");
+        return;
+    } else if command.args.len() == 2 {
+        if command.args[1] == "-a" {
+            (true, PathBuf::from(cwd))
+        } else {
+            (false, cwd.join(command.args[1]))
+        }
+    } else if command.args.len() == 3 {
+        if command.args[1] != "-a" {
+            kprintln!("Wrong arg {}! Usage: ls [-a] [directory]", command.args[1]);
+            return;
+        } else {
+            (true, cwd.join(command.args[2]))
+        }
+    } else {
+        (false, PathBuf::from(cwd))
+    };
+    let dir = match FILE_SYSTEM.open_dir(path) {
+        Ok(entry) => entry,
+        Err(err) => {
+            kprintln!("Error opening directory: {}", err);
+            return;
+        }
+    };
+    match dir.entries() {
+        Ok(entries) => for entry in entries {
+            let metadata = entry.metadata();
+            if metadata.hidden() && all == false {
+                continue;
+            }
+            kprint!("{}", if metadata.read_only() { 'r' } else { 'w' });
+            kprint!("{}", if metadata.hidden() { 'h' } else { 'v' });
+            kprint!("{}", if metadata.system() { 's' } else { '-' });
+            kprint!("{}", if metadata.volume_id() { 'i' } else { '-' });
+            kprint!("{}", if entry.is_dir() { 'd' } else { 'f' });
+            kprint!("{}", if metadata.archive() { 'a' } else { '-' });
+            kprint!("\t{:?}", metadata.created());
+            kprint!("\t{:?}", metadata.modified());
+            if entry.is_dir() {
+                kprint!("\t0");
+                kprintln!("\t{}/", entry.name());
+            } else {
+                kprint!("\t{}", entry.as_file().unwrap().size());
+                kprintln!("\t{}", entry.name());
+            }
+        },
+        Err(err) => kprintln!("Error listing dir: {}", err),
+    }
+}
+
+fn cd(command: &Command, cwd: PathBuf) -> PathBuf {
+    if command.args.len() != 2 {
+        kprintln!("Wrong number of args for cd");
+        return cwd;
+    }
+    FILE_SYSTEM
+        .canonicalize(cwd.join(command.args[1]))
+        .unwrap_or_else(|err| {
+            kprintln!("Error: {}", err);
+            cwd
+        })
+}
+
+fn pwd(_command: &Command, cwd: &Path) {
+    kprintln!("{}", cwd.display());
+}
+
+fn cat(command: &Command, cwd: &Path) {
+    for files in &command.args[1..] {
+        let file_path = cwd.join(files);
+        let mut file = match FILE_SYSTEM.open_file(file_path) {
+            Ok(entry) => entry,
+            Err(err) => {
+                kprintln!("Error: {}", err);
+                continue;
+            }
+        };
+        let mut contents = Vec::new();
+        match file.read_to_end(&mut contents) {
+            Ok(_) => kprintln!(
+                "{}",
+                str::from_utf8(&contents).unwrap_or("Error: file contain invalid UTF-8")
+            ),
+            Err(err) => kprintln!("Error reading file: {}", err),
+        }
+    }
+}
+
+fn gpio(command: &Command) {
+    if command.args.len() != 3 {
+        kprintln!("Usage: gpio [pin] [set|clear|level]");
+        return;
+    }
+
+    let pin_num = match command.args[1].parse() {
+        Ok(num) => num,
+        Err(err) => {
+            kprintln!("Unsupported pin number: {}", err);
+            return;
+        }
+    };
+
+    match command.args[2] {
+        "set" => {
+            let mut pin = Gpio::new(pin_num).into_output();
+            pin.set();
+            kprintln!("Pin {} set", pin_num);
+        }
+        "clear" => {
+            let mut pin = Gpio::new(pin_num).into_output();
+            pin.clear();
+            kprintln!("Pin {} cleared", pin_num);
+        }
+        "level" => {
+            let mut pin = Gpio::new(pin_num).into_input();
+            kprintln!("Pin {} level: {}", pin_num, pin.level());
+        }
+        op => kprintln!("Unsupported operation {}", op),
+    };
+}
+
+fn brk() {
+    unsafe {
+        asm!("brk 2" :::: "volatile");
+    }
+}
+
+fn current_el() {
+    // Does not work if CurrentEL is 0
+    // kprintln!("Current EL is {}", unsafe { aarch64::current_el() });
+}
+
+fn sleep(command: &Command) {
+    if command.args.len() > 2 {
+        kprintln!("Usage: sleep [time] ");
+    }
+    let time = if command.args.len() == 1 {
+        1000
+    } else {
+        command.args[1].parse().unwrap_or(1000)
+    };
+    let error: u64;
+    let time_elapsed: u64;
+    unsafe {
+        asm!("mov x0, $2
+              svc 1
+              mov $0, x0
+              mov $1, x7"
+              : "=r"(time_elapsed), "=r"(error)
+              : "r"(time)
+              : "x0", "x7")
+    }
+    if error != 0 {
+        kprintln!("Failed with {}", error);
+    } else {
+        kprintln!("Slept for {} msec", time_elapsed);
+    }
+}
\ No newline at end of file
diff --git a/kernel/src/traps/irq.rs b/kernel/src/traps/irq.rs
index 3d92f03..e9ca6ea 100644
--- a/kernel/src/traps/irq.rs
+++ b/kernel/src/traps/irq.rs
@@ -1,7 +1,17 @@
 use pi::interrupt::Interrupt;
 
 use traps::TrapFrame;
+use process::State;
+use pi::timer::tick_in;
+use process::TICK;
+use SCHEDULER;
 
 pub fn handle_irq(interrupt: Interrupt, tf: &mut TrapFrame) {
-    unimplemented!("handle_irq()")
+    match interrupt {
+        Interrupt::Timer1 => {
+            tick_in(TICK);
+            SCHEDULER.switch(State::Ready, tf).unwrap();
+        }
+        _ => unimplemented!("handle_irq()"),
+    }
 }
diff --git a/kernel/src/traps/mod.rs b/kernel/src/traps/mod.rs
index b66e46c..53c14df 100644
--- a/kernel/src/traps/mod.rs
+++ b/kernel/src/traps/mod.rs
@@ -11,6 +11,7 @@ use console::kprintln;
 use self::syndrome::Syndrome;
 use self::irq::handle_irq;
 use self::syscall::handle_syscall;
+use shell;
 
 #[repr(u16)]
 #[derive(Debug, PartialEq, Eq, Copy, Clone)]
@@ -42,6 +43,41 @@ pub struct Info {
 /// the value of the exception syndrome register. Finally, `tf` is a pointer to
 /// the trap frame for the exception.
 #[no_mangle]
-pub extern fn handle_exception(info: Info, esr: u32, tf: &mut TrapFrame) {
-    unimplemented!("handle_exception")
+pub extern "C" fn handle_exception(info: Info, esr: u32, tf: &mut TrapFrame) {
+    let syndrome = Syndrome::from(esr);
+    if info.kind == Kind::Synchronous {
+        // syndrome is only valid with sync
+        match syndrome {
+            Syndrome::Brk(_) => {
+                kprintln!("Got {:?} from {:?}", syndrome, info.source);
+                shell::shell(" [brk]$ ");
+
+                tf.elr += 4; // Skip the current brk instruction
+                return;
+            }
+            Syndrome::Svc(syscall) => {
+                handle_syscall(syscall, tf);
+                return;
+            }
+            _ => {}
+        }
+    } else if info.kind == Kind::Irq {
+        let controller = Controller::new();
+        use self::Interrupt::*;
+        for interrupt in [Timer1, Timer3, Usb, Gpio0, Gpio1, Gpio2, Gpio3, Uart].iter() {
+            if controller.is_pending(*interrupt) {
+                handle_irq(*interrupt, tf);
+                return;
+            }
+        }
+    }
+    kprintln!(
+        "Unhandled exception with info: {:?}, syndrome: {:?}, tf: {:?}",
+        info,
+        syndrome,
+        tf
+    );
+    loop {
+        unsafe { asm!("wfe") }
+    }
 }
diff --git a/kernel/src/traps/syndrome.rs b/kernel/src/traps/syndrome.rs
index 7ab7337..9e5bb78 100644
--- a/kernel/src/traps/syndrome.rs
+++ b/kernel/src/traps/syndrome.rs
@@ -6,12 +6,23 @@ pub enum Fault {
     Permission,
     Alignment,
     TlbConflict,
-    Other(u8)
+    Other(u8),
 }
 
 impl From<u32> for Fault {
     fn from(val: u32) -> Fault {
-        unimplemented!("From<u32> for Fault")
+        use self::Fault::*;
+
+        // ifsc or dfsc bits
+        match val & 0b111100 {
+            0b000000 => AddressSize,
+            0b000100 => Translation,
+            0b001000 => AccessFlag,
+            0b001100 => Permission,
+            0b100000 => Alignment,
+            0b110000 => TlbConflict,
+            _ => Other((val & 0b111111) as u8),
+        }
     }
 }
 
@@ -30,15 +41,9 @@ pub enum Syndrome {
     Hvc(u16),
     Smc(u16),
     MsrMrsSystem,
-    InstructionAbort {
-        kind: Fault,
-        level: u8,
-    },
+    InstructionAbort { kind: Fault, level: u8 },
     PCAlignmentFault,
-    DataAbort {
-        kind: Fault,
-        level: u8
-    },
+    DataAbort { kind: Fault, level: u8 },
     SpAlignmentFault,
     TrappedFpu,
     SError,
@@ -46,7 +51,7 @@ pub enum Syndrome {
     Step,
     Watchpoint,
     Brk(u16),
-    Other(u32)
+    Other(u32),
 }
 
 /// Converts a raw syndrome value (ESR) into a `Syndrome` (ref: D1.10.4).
@@ -54,6 +59,57 @@ impl From<u32> for Syndrome {
     fn from(esr: u32) -> Syndrome {
         use self::Syndrome::*;
 
-        unimplemented!("From<u32> for Syndrome")
+        let exception_class = esr >> 26;
+        let iss = esr & 0xFFFFFF;
+
+        match exception_class {
+            0b000000 => Unknown,
+            0b000001 => WfiWfe,
+            0b000011 => McrMrc,
+            0b000100 => McrrMrrc,
+            0b000101 => McrMrc,
+            0b000110 => LdcStc,
+            0b000111 => SimdFp,
+            0b001000 => Vmrs,
+            0b001100 => Mrrc,
+            0b001110 => IllegalExecutionState,
+            0b010001 => Svc((iss & 0xFFFF) as u16),
+            0b010010 => Hvc((iss & 0xFFFF) as u16),
+            0b010011 => Smc((iss & 0xFFFF) as u16),
+            0b010101 => Svc((iss & 0xFFFF) as u16),
+            0b010110 => Hvc((iss & 0xFFFF) as u16),
+            0b010111 => Smc((iss & 0xFFFF) as u16),
+            0b011000 => MsrMrsSystem,
+            0b100000 => InstructionAbort {
+                kind: iss.into(),
+                level: (iss & 0b11) as u8,
+            },
+            0b100001 => InstructionAbort {
+                kind: iss.into(),
+                level: (iss & 0b11) as u8,
+            },
+            0b100010 => PCAlignmentFault,
+            0b100100 => DataAbort {
+                kind: iss.into(),
+                level: (iss & 0b11) as u8,
+            },
+            0b100101 => DataAbort {
+                kind: iss.into(),
+                level: (iss & 0b11) as u8,
+            },
+            0b100110 => SpAlignmentFault,
+            0b101000 => TrappedFpu,
+            0b101100 => TrappedFpu,
+            0b101111 => SError,
+            0b110000 => Breakpoint,
+            0b110001 => Breakpoint,
+            0b110010 => Step,
+            0b110011 => Step,
+            0b110100 => Watchpoint,
+            0b110101 => Watchpoint,
+            0b111000 => Breakpoint,
+            0b111100 => Brk((iss & 0xFFFF) as u16),
+            other => Other(other),
+        }
     }
 }
diff --git a/kernel/src/traps/syscall.rs b/kernel/src/traps/syscall.rs
index b6d0abc..066b7ad 100644
--- a/kernel/src/traps/syscall.rs
+++ b/kernel/src/traps/syscall.rs
@@ -1,4 +1,8 @@
 use traps::TrapFrame;
+use pi::timer::current_time;
+use SCHEDULER;
+use process::State;
+use process::Process;
 
 /// Sleep for `ms` milliseconds.
 ///
@@ -8,9 +12,28 @@ use traps::TrapFrame;
 /// parameter: the approximate true elapsed time from when `sleep` was called to
 /// when `sleep` returned.
 pub fn sleep(ms: u32, tf: &mut TrapFrame) {
-    unimplemented!("syscall: sleep()")
+    let begin = current_time();
+    let time = begin + ms as u64 * 1000;
+    let polling_fn = Box::new(move |process: &mut Process| {
+        let current = current_time();
+        if current > time {
+            process.trap_frame.x1to29[6] = 0; // x7 = 0; succeed
+            process.trap_frame.x0 = (current - begin) / 1000; // x0 = elapsed time in ms
+            true
+        } else {
+            false
+        }
+    });
+    SCHEDULER.switch(State::Waiting(polling_fn), tf).unwrap();
 }
 
 pub fn handle_syscall(num: u16, tf: &mut TrapFrame) {
-    unimplemented!("handle_syscall()")
+    match num {
+        1 => {
+            sleep(tf.x0 as u32, tf);
+        }
+        _ => {
+            tf.x1to29[6] = 1; // x7 = 1, do not exist
+        }
+    }
 }
diff --git a/kernel/src/traps/trap_frame.rs b/kernel/src/traps/trap_frame.rs
index b608d7d..4b35bd3 100644
--- a/kernel/src/traps/trap_frame.rs
+++ b/kernel/src/traps/trap_frame.rs
@@ -2,4 +2,13 @@
 #[derive(Default, Debug, Copy, Clone)]
 pub struct TrapFrame {
     // FIXME: Fill me in.
+    pub elr: u64,
+    pub spsr: u64,
+    pub sp: u64,
+    pub tpidr: u64,
+    pub q0to31: [u128; 32],
+    pub x1to29: [u64; 29],
+    pub __r1: u64, // may be used to store lr temporaily
+    pub x30: u64,
+    pub x0: u64,
 }
diff --git a/pi/src/atags/atag.rs b/pi/src/atags/atag.rs
index 641d2f2..78025eb 100644
--- a/pi/src/atags/atag.rs
+++ b/pi/src/atags/atag.rs
@@ -1,4 +1,7 @@
 use atags::raw;
+use std::str;
+use std::ffi::CStr;
+use std::os::raw::c_char;
 
 pub use atags::raw::{Core, Mem};
 
@@ -9,24 +12,33 @@ pub enum Atag {
     Mem(raw::Mem),
     Cmd(&'static str),
     Unknown(u32),
-    None
+    None,
 }
 
 impl Atag {
     /// Returns `Some` if this is a `Core` ATAG. Otherwise returns `None`.
     pub fn core(self) -> Option<Core> {
-        unimplemented!()
+        match self {
+            Atag::Core(core) => Some(core),
+            _ => None,
+        }
     }
 
     /// Returns `Some` if this is a `Mem` ATAG. Otherwise returns `None`.
     pub fn mem(self) -> Option<Mem> {
-        unimplemented!()
+        match self {
+            Atag::Mem(mem) => Some(mem),
+            _ => None,
+        }
     }
 
     /// Returns `Some` with the command line string if this is a `Cmd` ATAG.
     /// Otherwise returns `None`.
     pub fn cmd(self) -> Option<&'static str> {
-        unimplemented!()
+        match self {
+            Atag::Cmd(cmd) => Some(cmd),
+            _ => None,
+        }
     }
 }
 
@@ -40,11 +52,14 @@ impl<'a> From<&'a raw::Atag> for Atag {
 
         unsafe {
             match (atag.tag, &atag.kind) {
-                (raw::Atag::CORE, &raw::Kind { core }) => unimplemented!(),
-                (raw::Atag::MEM, &raw::Kind { mem }) => unimplemented!(),
-                (raw::Atag::CMDLINE, &raw::Kind { ref cmd }) => unimplemented!(),
-                (raw::Atag::NONE, _) => unimplemented!(),
-                (id, _) => unimplemented!()
+                (raw::Atag::CORE, &raw::Kind { core }) => Atag::Core(core),
+                (raw::Atag::MEM, &raw::Kind { mem }) => Atag::Mem(mem),
+                (raw::Atag::CMDLINE, &raw::Kind { ref cmd }) => {
+                    let cmdline = CStr::from_ptr((&cmd.cmd as *const u8) as *const c_char);
+                    Atag::Cmd(str::from_utf8_unchecked(cmdline.to_bytes()))
+                }
+                (raw::Atag::NONE, _) => Atag::None,
+                (id, _) => Atag::Unknown(id),
             }
         }
     }
diff --git a/pi/src/atags/mod.rs b/pi/src/atags/mod.rs
index 97b9776..d20bc56 100644
--- a/pi/src/atags/mod.rs
+++ b/pi/src/atags/mod.rs
@@ -24,6 +24,13 @@ impl Iterator for Atags {
     type Item = Atag;
 
     fn next(&mut self) -> Option<Atag> {
-        unimplemented!("atags iterator")
+        // Skip the first CORE ATAG
+        match self.ptr.next() {
+            Some(next_atag) => {
+                self.ptr = next_atag;
+                Some(next_atag.into())
+            }
+            None => None
+        }
     }
 }
diff --git a/pi/src/atags/raw.rs b/pi/src/atags/raw.rs
index 19162c3..891e209 100644
--- a/pi/src/atags/raw.rs
+++ b/pi/src/atags/raw.rs
@@ -3,7 +3,7 @@
 pub struct Atag {
     pub dwords: u32,
     pub tag: u32,
-    pub kind: Kind
+    pub kind: Kind,
 }
 
 impl Atag {
@@ -20,7 +20,15 @@ impl Atag {
 
     /// Returns the ATAG following `self`, if there is one.
     pub fn next(&self) -> Option<&Atag> {
-        unimplemented!()
+        unsafe {
+            let addr = (self as *const Atag) as *const u32;
+            let next_atag = addr.offset(self.dwords as isize) as *mut Atag;
+
+            match (*next_atag).tag {
+                super::raw::Atag::NONE => None,
+                _ => next_atag.as_ref(),
+            }
+        }
     }
 }
 
@@ -29,7 +37,7 @@ impl Atag {
 pub union Kind {
     pub core: Core,
     pub mem: Mem,
-    pub cmd: Cmd
+    pub cmd: Cmd,
 }
 
 /// A `CORE` ATAG.
@@ -38,7 +46,7 @@ pub union Kind {
 pub struct Core {
     pub flags: u32,
     pub page_size: u32,
-    pub root_dev: u32
+    pub root_dev: u32,
 }
 
 /// A `MEM` ATAG.
@@ -46,7 +54,7 @@ pub struct Core {
 #[derive(Debug, Copy, Clone)]
 pub struct Mem {
     pub size: u32,
-    pub start: u32
+    pub start: u32,
 }
 
 /// A `CMDLINE` ATAG.
@@ -54,5 +62,5 @@ pub struct Mem {
 #[derive(Debug, Copy, Clone)]
 pub struct Cmd {
     /// The first byte of the command line string.
-    pub cmd: u8
+    pub cmd: u8,
 }
diff --git a/pi/src/gpio.rs b/pi/src/gpio.rs
index f70bfb5..f914de1 100644
--- a/pi/src/gpio.rs
+++ b/pi/src/gpio.rs
@@ -102,7 +102,8 @@ impl Gpio<Uninitialized> {
     /// Enables the alternative function `function` for `self`. Consumes self
     /// and returns a `Gpio` structure in the `Alt` state.
     pub fn into_alt(self, function: Function) -> Gpio<Alt> {
-        unimplemented!()
+        self.registers.FSEL[(self.pin / 10) as usize].or_mask((function as u32) << (3 * (self.pin % 10)));
+        self.transition()
     }
 
     /// Sets this pin to be an _output_ pin. Consumes self and returns a `Gpio`
@@ -121,12 +122,12 @@ impl Gpio<Uninitialized> {
 impl Gpio<Output> {
     /// Sets (turns on) the pin.
     pub fn set(&mut self) {
-        unimplemented!()
+        self.registers.SET[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 
     /// Clears (turns off) the pin.
     pub fn clear(&mut self) {
-        unimplemented!()
+        self.registers.CLR[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 }
 
@@ -134,6 +135,6 @@ impl Gpio<Input> {
     /// Reads the pin's value. Returns `true` if the level is high and `false`
     /// if the level is low.
     pub fn level(&mut self) -> bool {
-        unimplemented!()
+        self.registers.LEV[(self.pin / 32) as usize].has_mask(1 << (self.pin % 32))
     }
 }
diff --git a/pi/src/interrupt.rs b/pi/src/interrupt.rs
index 33eb61d..7d1ea63 100644
--- a/pi/src/interrupt.rs
+++ b/pi/src/interrupt.rs
@@ -4,7 +4,7 @@ use volatile::{Volatile, ReadVolatile};
 
 const INT_BASE: usize = IO_BASE + 0xB000 + 0x200;
 
-#[derive(Copy, Clone, PartialEq)]
+#[derive(Copy, Clone, PartialEq, Debug)]
 pub enum Interrupt {
     Timer1 = 1,
     Timer3 = 3,
@@ -20,6 +20,13 @@ pub enum Interrupt {
 #[allow(non_snake_case)]
 struct Registers {
     // FIXME: Fill me in.
+    IRQBasicPending: ReadVolatile<u32>,
+    IRQPending: [ReadVolatile<u32>; 2],
+    FIQControl: Volatile<u32>,
+    EnableIRQ: [Volatile<u32>; 2],
+    EnableBasicIRQ: Volatile<u32>,
+    DisableIRQ: [Volatile<u32>; 2],
+    DisableBasicIRQ: Volatile<u32>,
 }
 
 /// An interrupt controller. Used to enable and disable interrupts as well as to
@@ -38,16 +45,16 @@ impl Controller {
 
     /// Enables the interrupt `int`.
     pub fn enable(&mut self, int: Interrupt) {
-        unimplemented!()
+        self.registers.EnableIRQ[int as usize / 32].write(1 << (int as usize) % 32);
     }
 
     /// Disables the interrupt `int`.
     pub fn disable(&mut self, int: Interrupt) {
-        unimplemented!()
+        self.registers.DisableIRQ[int as usize / 32].write(1 << (int as usize) % 32);
     }
 
     /// Returns `true` if `int` is pending. Otherwise, returns `false`.
     pub fn is_pending(&self, int: Interrupt) -> bool {
-        unimplemented!()
+        self.registers.IRQPending[int as usize / 32].has_mask(1 << (int as usize) % 32)
     }
 }
diff --git a/pi/src/lib.rs b/pi/src/lib.rs
index 27b295e..3d1e81a 100644
--- a/pi/src/lib.rs
+++ b/pi/src/lib.rs
@@ -2,7 +2,6 @@
 #![feature(const_fn)]
 #![feature(asm)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(never_type)]
 #![feature(pointer_methods)]
diff --git a/pi/src/timer.rs b/pi/src/timer.rs
index 0086c0b..42f034c 100644
--- a/pi/src/timer.rs
+++ b/pi/src/timer.rs
@@ -30,35 +30,46 @@ impl Timer {
     /// Reads the system timer's counter and returns the 64-bit counter value.
     /// The returned value is the number of elapsed microseconds.
     pub fn read(&self) -> u64 {
-        unimplemented!()
+        let low = self.registers.CLO.read();
+        let high = self.registers.CHI.read();
+        ((high as u64) << 32) | (low as u64)
     }
 
     /// Sets up a match in timer 1 to occur `us` microseconds from now. If
     /// interrupts for timer 1 are enabled and IRQs are unmasked, then a timer
     /// interrupt will be issued in `us` microseconds.
     pub fn tick_in(&mut self, us: u32) {
-        unimplemented!()
+        let current_low = self.registers.CLO.read();
+        let compare = current_low.wrapping_add(us);
+        self.registers.COMPARE[1].write(compare); // timer 1
+        self.registers.CS.or_mask(0b0010); // clear timer 1 interrupt
     }
 }
 
 /// Returns the current time in microseconds.
 pub fn current_time() -> u64 {
-    unimplemented!()
+    Timer::new().read()
 }
 
 /// Spins until `us` microseconds have passed.
 pub fn spin_sleep_us(us: u64) {
-    unimplemented!()
+    let old = current_time();
+    loop {
+        let new = current_time();
+        if old + us <= new {
+            break;
+        }
+    }
 }
 
 /// Spins until `ms` milliseconds have passed.
 pub fn spin_sleep_ms(ms: u64) {
-    unimplemented!()
+    spin_sleep_us(ms * 1000);
 }
 
 /// Sets up a match in timer 1 to occur `us` microseconds from now. If
 /// interrupts for timer 1 are enabled and IRQs are unmasked, then a timer
 /// interrupt will be issued in `us` microseconds.
 pub fn tick_in(us: u32) {
-    unimplemented!()
+    Timer::new().tick_in(us)
 }
diff --git a/pi/src/uart.rs b/pi/src/uart.rs
index 92b6159..91ca7a3 100644
--- a/pi/src/uart.rs
+++ b/pi/src/uart.rs
@@ -24,6 +24,26 @@ enum LsrStatus {
 #[allow(non_snake_case)]
 struct Registers {
     // FIXME: Declare the "MU" registers from page 8.
+    AUX_MU_IO_REG: Volatile<u8>,
+    __r0: [Reserved<u8>; 3],
+    AUX_MU_IER_REG: Volatile<u8>,
+    __r1: [Reserved<u8>; 3],
+    AUX_MU_IIR_REG: Volatile<u8>,
+    __r2: [Reserved<u8>; 3],
+    AUX_MU_LCR_REG: Volatile<u8>,
+    __r3: [Reserved<u8>; 3],
+    AUX_MU_MCR_REG: Volatile<u8>,
+    __r4: [Reserved<u8>; 3],
+    AUX_MU_LSR_REG: ReadVolatile<u8>,
+    __r5: [Reserved<u8>; 3],
+    AUX_MU_MSR_REG: ReadVolatile<u8>,
+    __r6: [Reserved<u8>; 3],
+    AUX_MU_SCRATCH: Volatile<u8>,
+    __r7: [Reserved<u8>; 3],
+    AUX_MU_CNTL_REG: Volatile<u8>,
+    __r8: [Reserved<u8>; 3],
+    AUX_MU_STAT_REG: ReadVolatile<u32>,
+    AUX_MU_BAUD: Volatile<u16>
 }
 
 /// The Raspberry Pi's "mini UART".
@@ -46,27 +66,42 @@ impl MiniUart {
             (*AUX_ENABLES).or_mask(1);
             &mut *(MU_REG_BASE as *mut Registers)
         };
-
+        
         // FIXME: Implement remaining mini UART initialization.
-        unimplemented!()
+        // GPIO 14 15 set to TX/RX
+        Gpio::new(14).into_alt(Function::Alt5);
+        Gpio::new(15).into_alt(Function::Alt5);
+        registers.AUX_MU_LCR_REG.or_mask(0b11); // 8-bit data size
+        // baudrate = system_clock_freq / (8 * (baud_reg + 1))
+        // system_clock_freq is 250MHz (Page 10)
+        // 250MHz / 8 / 115200 - 1 = 270
+        // Using 230400 for speed
+        registers.AUX_MU_BAUD.write(135); // 16-bit baudrate register
+        registers.AUX_MU_CNTL_REG.or_mask(0b11); // enable TX & RX
+
+        MiniUart {
+            registers: registers,
+            timeout: None,
+        }
     }
 
     /// Set the read timeout to `milliseconds` milliseconds.
     pub fn set_read_timeout(&mut self, milliseconds: u32) {
-        unimplemented!()
+        self.timeout = Some(milliseconds)
     }
 
     /// Write the byte `byte`. This method blocks until there is space available
     /// in the output FIFO.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        while !self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::TxAvailable as u8) { };
+        self.registers.AUX_MU_IO_REG.write(byte);
     }
 
     /// Returns `true` if there is at least one byte ready to be read. If this
     /// method returns `true`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately. This method does not block.
     pub fn has_byte(&self) -> bool {
-        unimplemented!()
+        self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::DataReady as u8)
     }
 
     /// Blocks until there is a byte ready to read. If a read timeout is set,
@@ -78,17 +113,50 @@ impl MiniUart {
     /// returns `Ok(())`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately.
     pub fn wait_for_byte(&self) -> Result<(), ()> {
-        unimplemented!()
+        match self.timeout {
+            None => {
+                loop {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+            },
+            Some(timeout) => {
+                let old = timer::current_time();
+                let deadline = old + (timeout as u64) * 1000; // Internal clock unit is microsecond, but timeout unit is millisecond
+                while deadline >= timer::current_time() {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+                Err(())
+            }
+        }
     }
 
     /// Reads a byte. Blocks indefinitely until a byte is ready to be read.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        while !self.has_byte() { }
+        self.registers.AUX_MU_IO_REG.read()
     }
 }
 
 // FIXME: Implement `fmt::Write` for `MiniUart`. A b'\r' byte should be written
 // before writing any b'\n' byte.
+impl fmt::Write for MiniUart {
+    fn write_str(&mut self, s: &str) -> fmt::Result {
+        for byte in s.bytes() {
+            match byte {
+                b'\n' => {
+                    self.write_byte(b'\r');
+                    self.write_byte(b'\n');
+                },
+                _ => self.write_byte(byte)
+            }
+        }
+        Ok(())
+    }
+}
 
 #[cfg(feature = "std")]
 mod uart_io {
@@ -104,4 +172,34 @@ mod uart_io {
     //
     // The `io::Write::write()` method must write all of the requested bytes
     // before returning.
+    impl io::Read for MiniUart {
+       fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+           match self.wait_for_byte() {
+               Ok(()) => {
+                   let mut index = 0;
+                   while self.has_byte() && index < buf.len() {
+                       buf[index] = self.read_byte();
+                       index += 1;
+                   }
+                   Ok(index)
+               },
+               Err(()) => {
+                   Err(io::Error::new(io::ErrorKind::TimedOut, "reading UART timed out"))
+               }
+           }
+       }
+    }
+
+    impl io::Write for MiniUart {
+       fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+           for byte in buf {
+               self.write_byte(*byte);
+           }
+           Ok(buf.len())
+       }
+
+       fn flush(&mut self) -> io::Result<()> {
+           unimplemented!()
+       }
+    }
 }
diff --git a/std/src/collections/hash/map.rs b/std/src/collections/hash/map.rs
index 4114354..ca6c7c9 100644
--- a/std/src/collections/hash/map.rs
+++ b/std/src/collections/hash/map.rs
@@ -1972,7 +1972,7 @@ impl<'a, K, V> Placer<V> for Entry<'a, K, V> {
 #[unstable(feature = "collection_placement",
            reason = "placement protocol is subject to change",
            issue = "30172")]
-impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {
+unsafe impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {
     fn pointer(&mut self) -> *mut V {
         self.bucket.read_mut().1
     }
