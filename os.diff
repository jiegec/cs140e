diff --git a/bootloader/.vscode/settings.json b/bootloader/.vscode/settings.json
index e69de29..2dd73f2 100644
--- a/bootloader/.vscode/settings.json
+++ b/bootloader/.vscode/settings.json
@@ -0,0 +1,4 @@
+{
+    "rust.target": "aarch64-none-elf",
+    "rust.sysroot": "/Users/macbookair/.xargo"
+}
\ No newline at end of file
diff --git a/bootloader/src/kmain.rs b/bootloader/src/kmain.rs
index 591a219..59e3ebc 100644
--- a/bootloader/src/kmain.rs
+++ b/bootloader/src/kmain.rs
@@ -1,7 +1,11 @@
 #![feature(asm, lang_items)]
 
-extern crate xmodem;
 extern crate pi;
+extern crate xmodem;
+
+use std::io;
+use std::io::Write;
+use pi::uart::MiniUart;
 
 pub mod lang_items;
 
@@ -19,11 +23,31 @@ const MAX_BINARY_SIZE: usize = BOOTLOADER_START_ADDR - BINARY_START_ADDR;
 fn jump_to(addr: *mut u8) -> ! {
     unsafe {
         asm!("br $0" : : "r"(addr as usize));
-        loop { asm!("nop" :::: "volatile")  }
+        loop {
+            asm!("nop" :::: "volatile")
+        }
     }
 }
 
 #[no_mangle]
 pub extern "C" fn kmain() {
     // FIXME: Implement the bootloader.
+    let mut uart = MiniUart::new();
+    uart.set_read_timeout(750);
+
+    loop {
+        let dest = unsafe { std::slice::from_raw_parts_mut(BINARY_START, MAX_BINARY_SIZE) };
+        match xmodem::Xmodem::receive(&mut uart, io::Cursor::new(dest)) {
+            Ok(_) => {
+                // Succeed
+                jump_to(BINARY_START)
+            }
+            Err(err) => match err.kind() {
+                io::ErrorKind::TimedOut => continue,
+                io::ErrorKind::InvalidData => continue, // might receive 0x00 when no input
+                _ => uart.write_fmt(format_args!("Error: {:?}\r\n", err))
+                    .unwrap(),
+            },
+        }
+    }
 }
diff --git a/kernel/.vscode/settings.json b/kernel/.vscode/settings.json
index e69de29..2dd73f2 100644
--- a/kernel/.vscode/settings.json
+++ b/kernel/.vscode/settings.json
@@ -0,0 +1,4 @@
+{
+    "rust.target": "aarch64-none-elf",
+    "rust.sysroot": "/Users/macbookair/.xargo"
+}
\ No newline at end of file
diff --git a/kernel/src/allocator/bump.rs b/kernel/src/allocator/bump.rs
index e8741cf..8b7f0e8 100644
--- a/kernel/src/allocator/bump.rs
+++ b/kernel/src/allocator/bump.rs
@@ -13,7 +13,10 @@ impl Allocator {
     /// Creates a new bump allocator that will allocate memory from the region
     /// starting at address `start` and ending at address `end`.
     pub fn new(start: usize, end: usize) -> Allocator {
-        unimplemented!("bump allocator")
+        Allocator {
+            current: start,
+            end: start + end,
+        }
     }
 
     /// Allocates memory. Returns a pointer meeting the size and alignment
@@ -37,7 +40,22 @@ impl Allocator {
     /// (`AllocError::Exhausted`) or `layout` does not meet this allocator's
     /// size or alignment constraints (`AllocError::Unsupported`).
     pub fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {
-        unimplemented!("bump allocation")
+        let new_start = align_up(self.current, layout.align()) + layout.size();
+
+        if new_start >= self.end {
+            return Err(AllocErr::Exhausted { request: layout });
+        }
+
+        /*
+        use console::noblock_kprintln;
+        noblock_kprintln!(
+            "Allocating buffer from {} to {}",
+            new_start - layout.size(),
+            new_start
+        );
+        */
+        self.current = new_start;
+        Ok((new_start - layout.size()) as *mut u8)
     }
 
     /// Deallocates the memory referenced by `ptr`.
@@ -53,7 +71,15 @@ impl Allocator {
     ///
     /// Parameters not meeting these conditions may result in undefined
     /// behavior.
-    pub fn dealloc(&mut self, _ptr: *mut u8, _layout: Layout) {
-        unimplemented!("bump deallocation")
+    pub fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {
+        // Do nothing
+        /*
+        use console::noblock_kprintln;
+        noblock_kprintln!(
+            "Deallocating buffer from {} to {}",
+            ptr as usize,
+            ptr as usize + layout.size()
+        );
+        */
     }
 }
diff --git a/kernel/src/allocator/mod.rs b/kernel/src/allocator/mod.rs
index 5e23e6b..4a9ab2b 100644
--- a/kernel/src/allocator/mod.rs
+++ b/kernel/src/allocator/mod.rs
@@ -7,6 +7,7 @@ mod imp;
 use mutex::Mutex;
 use alloc::heap::{Alloc, AllocErr, Layout};
 use std::cmp::max;
+use pi::atags::Atags;
 
 /// Thread-safe (locking) wrapper around a particular memory allocator.
 #[derive(Debug)]
@@ -54,7 +55,11 @@ unsafe impl<'a> Alloc for &'a Allocator {
     /// (`AllocError::Exhausted`) or `layout` does not meet this allocator's
     /// size or alignment constraints (`AllocError::Unsupported`).
     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {
-        self.0.lock().as_mut().expect("allocator uninitialized").alloc(layout)
+        self.0
+            .lock()
+            .as_mut()
+            .expect("allocator uninitialized")
+            .alloc(layout)
     }
 
     /// Deallocates the memory referenced by `ptr`.
@@ -71,7 +76,11 @@ unsafe impl<'a> Alloc for &'a Allocator {
     /// Parameters not meeting these conditions may result in undefined
     /// behavior.
     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {
-        self.0.lock().as_mut().expect("allocator uninitialized").dealloc(ptr, layout);
+        self.0
+            .lock()
+            .as_mut()
+            .expect("allocator uninitialized")
+            .dealloc(ptr, layout);
     }
 }
 
@@ -82,7 +91,21 @@ extern "C" {
 /// Returns the (start address, end address) of the available memory on this
 /// system.
 fn memory_map() -> Option<(usize, usize)> {
-    let binary_end = unsafe { (&_end as *const u8) as u32 };
+    let binary_end = unsafe { (&_end as *const u8) as usize };
 
-    unimplemented!("memory map fetch")
+    for tag in Atags::get() {
+        match tag.mem() {
+            Some(mem) => {
+                let mut start = mem.start as usize;
+                let end = (mem.start + mem.size) as usize;
+                if binary_end < end {
+                    start = max(start, binary_end);
+                }
+                return Some((start, end));
+            }
+            _ => {}
+        }
+    }
+
+    None
 }
diff --git a/kernel/src/allocator/util.rs b/kernel/src/allocator/util.rs
index f855fce..acc66cd 100644
--- a/kernel/src/allocator/util.rs
+++ b/kernel/src/allocator/util.rs
@@ -6,7 +6,11 @@
 ///
 /// Panics if `align` is not a power of 2.
 pub fn align_down(addr: usize, align: usize) -> usize {
-    unimplemented!()
+    if (align & (align - 1)) != 0 {
+        panic!("align_down: align not a power of 2");
+    }
+
+    addr & !(align - 1)
 }
 
 /// Align `addr` upwards to the nearest multiple of `align`.
@@ -17,7 +21,11 @@ pub fn align_down(addr: usize, align: usize) -> usize {
 ///
 /// Panics if `align` is not a power of 2.
 pub fn align_up(addr: usize, align: usize) -> usize {
-    unimplemented!()
+    if (align & (align - 1)) != 0 {
+        panic!("align_down: align not a power of 2");
+    }
+
+    (addr + align - 1) & !(align - 1)
 }
 
 #[cfg(test)]
diff --git a/kernel/src/console.rs b/kernel/src/console.rs
index 557772e..8df9131 100644
--- a/kernel/src/console.rs
+++ b/kernel/src/console.rs
@@ -7,7 +7,7 @@ use mutex::Mutex;
 
 /// A global singleton allowing read/write access to the console.
 pub struct Console {
-    inner: Option<MiniUart>
+    inner: Option<MiniUart>,
 }
 
 impl Console {
@@ -19,35 +19,36 @@ impl Console {
     /// Initializes the console if it's not already initialized.
     #[inline]
     fn initialize(&mut self) {
-        unimplemented!()
+        self.inner.get_or_insert_with(&MiniUart::new);
     }
 
     /// Returns a mutable borrow to the inner `MiniUart`, initializing it as
     /// needed.
     fn inner(&mut self) -> &mut MiniUart {
-        unimplemented!()
+        self.initialize();
+        self.inner.as_mut().unwrap()
     }
 
     /// Reads a byte from the UART device, blocking until a byte is available.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        self.inner().read_byte()
     }
 
     /// Writes the byte `byte` to the UART device.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        self.inner().write_byte(byte)
     }
 }
 
 impl io::Read for Console {
     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().read(buf)
     }
 }
 
 impl io::Write for Console {
     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
-        unimplemented!()
+        self.inner().write(buf)
     }
 
     fn flush(&mut self) -> io::Result<()> {
@@ -57,7 +58,7 @@ impl io::Write for Console {
 
 impl fmt::Write for Console {
     fn write_str(&mut self, s: &str) -> fmt::Result {
-        unimplemented!()
+        self.inner().write_str(s)
     }
 }
 
@@ -83,3 +84,23 @@ pub macro kprintln {
 pub macro kprint($($arg:tt)*) {
     _print(format_args!($($arg)*))
 }
+
+/// Internal function called by the `noblock_kprint[ln]!` macros.
+#[doc(hidden)]
+pub fn _noblock_print(args: fmt::Arguments) {
+    use std::fmt::Write;
+    let mut console = Console::new();
+    console.write_fmt(args).unwrap();
+}
+
+/// Like `println!`, but non-blocking and for kernel-space.
+pub macro noblock_kprintln {
+    () => (noblock_kprint!("\n")),
+    ($fmt:expr) => (noblock_kprint!(concat!($fmt, "\n"))),
+    ($fmt:expr, $($arg:tt)*) => (noblock_kprint!(concat!($fmt, "\n"), $($arg)*))
+}
+
+/// Like `print!`, but non-blocking and for kernel-space.
+pub macro noblock_kprint($($arg:tt)*) {
+    _noblock_print(format_args!($($arg)*))
+}
diff --git a/kernel/src/kmain.rs b/kernel/src/kmain.rs
index 471db36..fedb2d7 100644
--- a/kernel/src/kmain.rs
+++ b/kernel/src/kmain.rs
@@ -4,7 +4,6 @@
 #![feature(asm)]
 #![feature(optin_builtin_traits)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(exclusive_range_pattern)]
 #![feature(alloc, allocator_api, global_allocator)]
@@ -16,6 +15,12 @@ extern crate pi;
 extern crate stack_vec;
 
 pub mod allocator;
+use pi::gpio::Gpio;
+use std::fmt::Write;
+use pi::uart::MiniUart;
+use pi::timer::spin_sleep_ms;
+use pi::timer::current_time;
+
 pub mod lang_items;
 pub mod mutex;
 pub mod console;
@@ -28,8 +33,52 @@ use allocator::Allocator;
 #[global_allocator]
 pub static ALLOCATOR: Allocator = Allocator::uninitialized();
 
+use console::{kprintln, CONSOLE};
+
+fn blinky() {
+    let pin16 = Gpio::new(16);
+    let mut pin_out16 = pin16.into_output();
+
+    loop {
+        pin_out16.set();
+        spin_sleep_ms(1000);
+        pin_out16.clear();
+        spin_sleep_ms(1000);
+    }
+}
+
+fn echo() {
+    let mut uart = MiniUart::new();
+
+    loop {
+        let byte = uart.read_byte();
+        uart.write_byte(byte);
+    }
+}
+
+fn time() {
+    loop {
+        kprintln!("Current time: {}", current_time());
+        spin_sleep_ms(1000);
+    }
+}
+
+fn hex() {
+    let mut console = CONSOLE.lock();
+    loop {
+        let byte = console.read_byte();
+        console.write_fmt(format_args!("{:#X}", byte)).unwrap();
+    }
+}
+
 #[no_mangle]
 #[cfg(not(test))]
 pub extern "C" fn kmain() {
     ALLOCATOR.initialize();
+    // FIXME: Start the shell.
+    // blinky();
+    // echo();
+    // time();
+    // hex();
+    shell::shell("> ");
 }
diff --git a/kernel/src/lang_items.rs b/kernel/src/lang_items.rs
index fb03697..61b7d4e 100644
--- a/kernel/src/lang_items.rs
+++ b/kernel/src/lang_items.rs
@@ -1,10 +1,19 @@
 #[no_mangle]
 #[cfg(not(test))]
 #[lang = "panic_fmt"]
-pub extern fn panic_fmt(fmt: ::std::fmt::Arguments, file: &'static str, line: u32) -> ! {
+pub extern "C" fn panic_fmt(fmt: ::std::fmt::Arguments, file: &'static str, line: u32) -> ! {
     // FIXME: Print `fmt`, `file`, and `line` to the console.
+    {
+        // Avoid deadlock
+        use console::noblock_kprintln;
+        noblock_kprintln!("Kernel Panic at file {}\n\t\tline {}: {}", file, line, fmt);
+    }
 
-    loop { unsafe { asm!("wfe") } }
+    loop {
+        unsafe { asm!("wfe") }
+    }
 }
 
-#[cfg(not(test))] #[lang = "eh_personality"] pub extern fn eh_personality() {}
+#[cfg(not(test))]
+#[lang = "eh_personality"]
+pub extern "C" fn eh_personality() {}
diff --git a/kernel/src/mutex.rs b/kernel/src/mutex.rs
index e52b172..394015f 100644
--- a/kernel/src/mutex.rs
+++ b/kernel/src/mutex.rs
@@ -1,6 +1,6 @@
 use std::sync::atomic::{AtomicBool, Ordering};
 use std::cell::UnsafeCell;
-use std::ops::{DerefMut, Deref, Drop};
+use std::ops::{Deref, DerefMut, Drop};
 use std::fmt;
 
 #[repr(align(32))]
@@ -9,21 +9,21 @@ pub struct Mutex<T> {
     lock: AtomicBool,
 }
 
-unsafe impl<T: Send> Send for Mutex<T> { }
-unsafe impl<T: Send> Sync for Mutex<T> { }
+unsafe impl<T: Send> Send for Mutex<T> {}
+unsafe impl<T: Send> Sync for Mutex<T> {}
 
 pub struct MutexGuard<'a, T: 'a> {
-    lock: &'a Mutex<T>
+    lock: &'a Mutex<T>,
 }
 
-impl<'a, T> !Send for MutexGuard<'a, T> { }
-unsafe impl<'a, T: Sync> Sync for MutexGuard<'a, T> { }
+impl<'a, T> !Send for MutexGuard<'a, T> {}
+unsafe impl<'a, T: Sync> Sync for MutexGuard<'a, T> {}
 
 impl<T> Mutex<T> {
     pub const fn new(val: T) -> Mutex<T> {
         Mutex {
             lock: AtomicBool::new(false),
-            data: UnsafeCell::new(val)
+            data: UnsafeCell::new(val),
         }
     }
 }
@@ -48,7 +48,7 @@ impl<T> Mutex<T> {
         loop {
             match self.try_lock() {
                 Some(guard) => return guard,
-                None => continue
+                None => continue,
             }
         }
     }
@@ -62,7 +62,7 @@ impl<'a, T: 'a> Deref for MutexGuard<'a, T> {
     type Target = T;
 
     fn deref(&self) -> &T {
-        unsafe { & *self.lock.data.get() }
+        unsafe { &*self.lock.data.get() }
     }
 }
 
@@ -82,7 +82,7 @@ impl<T: fmt::Debug> fmt::Debug for Mutex<T> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match self.try_lock() {
             Some(guard) => f.debug_struct("Mutex").field("data", &&*guard).finish(),
-            None => f.debug_struct("Mutex").field("data", &"<locked>").finish()
+            None => f.debug_struct("Mutex").field("data", &"<locked>").finish(),
         }
     }
 }
diff --git a/kernel/src/shell.rs b/kernel/src/shell.rs
index 03fb8fb..0174241 100644
--- a/kernel/src/shell.rs
+++ b/kernel/src/shell.rs
@@ -1,16 +1,37 @@
-use stack_vec::StackVec;
 use console::{kprint, kprintln, CONSOLE};
+use std::str;
+use pi::timer::{current_time, spin_sleep_ms};
 
 /// Error type for `Command` parse failures.
 #[derive(Debug)]
 enum Error {
     Empty,
-    TooManyArgs
 }
 
+const BEL: u8 = 0x07u8;
+const BS: u8 = 0x08u8;
+const LF: u8 = 0x0au8;
+const CR: u8 = 0x0du8;
+const ESC: u8 = 0x1bu8;
+const DEL: u8 = 0x7fu8;
+
+const BANNER: &str = r#"
+                 _ _ ___         
+             __-         `-_    
+         ___/__        ã€‡   \ 
+     - '     _/             /
+   '_'             /
+ / _- ---            __ -
+/`     |          _ / \  \
+       |       -       \ |
+        \    /          V
+          \  |
+            \ \
+              \"#;
+
 /// A structure representing a single shell command.
 struct Command<'a> {
-    args: StackVec<'a, &'a str>
+    args: Vec<&'a str>,
 }
 
 impl<'a> Command<'a> {
@@ -21,10 +42,10 @@ impl<'a> Command<'a> {
     ///
     /// If `s` contains no arguments, returns `Error::Empty`. If there are more
     /// arguments than `buf` can hold, returns `Error::TooManyArgs`.
-    fn parse(s: &'a str, buf: &'a mut [&'a str]) -> Result<Command<'a>, Error> {
-        let mut args = StackVec::new(buf);
+    fn parse(s: &str) -> Result<Command, Error> {
+        let mut args = Vec::with_capacity(64);
         for arg in s.split(' ').filter(|a| !a.is_empty()) {
-            args.push(arg).map_err(|_| Error::TooManyArgs)?;
+            args.push(arg);
         }
 
         if args.is_empty() {
@@ -36,12 +57,185 @@ impl<'a> Command<'a> {
 
     /// Returns this command's path. This is equivalent to the first argument.
     fn path(&self) -> &str {
-        unimplemented!()
+        self.args[0]
     }
 }
 
 /// Starts a shell using `prefix` as the prefix for each line. This function
 /// never returns: it is perpetually in a shell loop.
 pub fn shell(prefix: &str) -> ! {
-    unimplemented!()
+    spin_sleep_ms(200); // wait a little time for client to attach
+    kprintln!("{}", BANNER);
+
+    loop {
+        kprint!("{}", prefix);
+
+        let line = read_line();
+        match Command::parse(&line) {
+            Ok(command) => {
+                let path = command.path();
+                match path {
+                    "echo" => echo(&command),
+                    "echohex" => echohex(&command),
+                    "exit" => exit(&command),
+                    "panic" => panic(&command),
+                    "uptime" => uptime(&command),
+                    _ => kprintln!("unknown command: {}", path),
+                }
+            }
+            Err(Error::Empty) => {
+                // Ignore
+            }
+        }
+    }
+}
+
+fn read_line() -> String {
+    let mut console = CONSOLE.lock();
+    let mut cursor = 0;
+    let mut line_vec = Vec::with_capacity(512);
+    loop {
+        match console.read_byte() {
+            BS | DEL => {
+                // Backspace
+                if cursor > 0 {
+                    cursor -= 1;
+                    line_vec.remove(cursor);
+
+                    console.write_byte(BS);
+                    for byte in &line_vec[cursor..] {
+                        console.write_byte(*byte);
+                    }
+                    console.write_byte(b' ');
+                    for _i in cursor..line_vec.len() {
+                        console.write_byte(BS);
+                    }
+                    console.write_byte(BS);
+                } else {
+                    console.write_byte(BEL);
+                }
+            }
+            CR | LF => {
+                // Return
+                console.write_byte(CR);
+                console.write_byte(LF);
+                break;
+            }
+            ESC => {
+                match console.read_byte() {
+                    b'[' => {
+                        match console.read_byte() {
+                            b'D' => {
+                                // Left arrow
+                                if cursor > 0 {
+                                    cursor -= 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'D');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            b'C' => {
+                                // Right arrow
+                                if cursor < line_vec.len() {
+                                    cursor += 1;
+                                    console.write_byte(ESC);
+                                    console.write_byte(b'[');
+                                    console.write_byte(b'C');
+                                } else {
+                                    console.write_byte(BEL);
+                                }
+                            }
+                            _ => {
+                                console.write_byte(BEL);
+                            }
+                        }
+                    }
+                    _ => {
+                        console.write_byte(BEL);
+                    }
+                }
+            }
+            byte if byte.is_ascii_graphic() || byte == b' ' => {
+                line_vec.insert(cursor, byte);
+                for byte in &line_vec[cursor..] {
+                    console.write_byte(*byte);
+                }
+                cursor += 1;
+                for _i in cursor..line_vec.len() {
+                    console.write_byte(BS);
+                }
+            }
+            _ => {
+                // unrecognized characters
+                console.write_byte(BEL);
+            }
+        }
+    }
+
+    String::from_utf8(line_vec).unwrap_or_default()
+}
+
+fn echo(command: &Command) {
+    if command.args.len() > 1 {
+        kprint!("{}", command.args[1]);
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" {}", *arg);
+            }
+        }
+    }
+
+    kprintln!();
+}
+
+fn echohex(command: &Command) {
+    echo(&command);
+    if command.args.len() > 1 {
+        for byte in command.args[1].bytes() {
+            kprint!("{:02X}", byte);
+        }
+        if command.args.len() > 2 {
+            for arg in &command.args[2..] {
+                kprint!(" ");
+                for byte in arg.bytes() {
+                    kprint!("{:02X}", byte);
+                }
+            }
+        }
+    }
+
+    kprintln!();
+}
+
+fn uptime(_command: &Command) {
+    let time = current_time();
+    let sec = time / 1000 / 1000;
+    let min = sec / 60;
+    let hour = min / 60;
+    let day = hour / 24;
+    kprintln!(
+        "Uptime: {} day(s), {:02}:{:02}:{:02}",
+        day,
+        hour % 24,
+        min % 60,
+        sec % 60
+    );
+}
+
+fn exit(_command: &Command) -> ! {
+    kprintln!("Exit to bootloader. Detach and send a new kernel to continue.");
+    // in line with bootloader
+    const BOOTLOADER_START_ADDR: usize = 0x4000000;
+    unsafe {
+        asm!("br $0" : : "r"(BOOTLOADER_START_ADDR));
+        loop {
+            asm!("nop" :::: "volatile")
+        }
+    }
+}
+
+fn panic(_command: &Command) -> ! {
+    panic!("You ask me to panic!");
 }
diff --git a/pi/src/atags/atag.rs b/pi/src/atags/atag.rs
index 641d2f2..bc40fcb 100644
--- a/pi/src/atags/atag.rs
+++ b/pi/src/atags/atag.rs
@@ -1,4 +1,6 @@
 use atags::raw;
+use std::slice;
+use std::str;
 
 pub use atags::raw::{Core, Mem};
 
@@ -9,24 +11,33 @@ pub enum Atag {
     Mem(raw::Mem),
     Cmd(&'static str),
     Unknown(u32),
-    None
+    None,
 }
 
 impl Atag {
     /// Returns `Some` if this is a `Core` ATAG. Otherwise returns `None`.
     pub fn core(self) -> Option<Core> {
-        unimplemented!()
+        match self {
+            Atag::Core(core) => Some(core),
+            _ => None,
+        }
     }
 
     /// Returns `Some` if this is a `Mem` ATAG. Otherwise returns `None`.
     pub fn mem(self) -> Option<Mem> {
-        unimplemented!()
+        match self {
+            Atag::Mem(mem) => Some(mem),
+            _ => None,
+        }
     }
 
     /// Returns `Some` with the command line string if this is a `Cmd` ATAG.
     /// Otherwise returns `None`.
     pub fn cmd(self) -> Option<&'static str> {
-        unimplemented!()
+        match self {
+            Atag::Cmd(cmd) => Some(cmd),
+            _ => None,
+        }
     }
 }
 
@@ -40,11 +51,15 @@ impl<'a> From<&'a raw::Atag> for Atag {
 
         unsafe {
             match (atag.tag, &atag.kind) {
-                (raw::Atag::CORE, &raw::Kind { core }) => unimplemented!(),
-                (raw::Atag::MEM, &raw::Kind { mem }) => unimplemented!(),
-                (raw::Atag::CMDLINE, &raw::Kind { ref cmd }) => unimplemented!(),
-                (raw::Atag::NONE, _) => unimplemented!(),
-                (id, _) => unimplemented!()
+                (raw::Atag::CORE, &raw::Kind { core }) => Atag::Core(core),
+                (raw::Atag::MEM, &raw::Kind { mem }) => Atag::Mem(mem),
+                (raw::Atag::CMDLINE, &raw::Kind { ref cmd }) => {
+                    let len = 4 * (atag.dwords - 2) as usize;
+                    let cmdline = slice::from_raw_parts(&cmd.cmd as *const u8, len);
+                    Atag::Cmd(str::from_utf8_unchecked(cmdline))
+                }
+                (raw::Atag::NONE, _) => Atag::None,
+                (id, _) => Atag::Unknown(id),
             }
         }
     }
diff --git a/pi/src/atags/mod.rs b/pi/src/atags/mod.rs
index 97b9776..319f4f2 100644
--- a/pi/src/atags/mod.rs
+++ b/pi/src/atags/mod.rs
@@ -2,20 +2,21 @@ mod raw;
 mod atag;
 
 pub use self::atag::*;
+use std::ptr;
 
 /// The address at which the firmware loads the ATAGS.
 const ATAG_BASE: usize = 0x100;
 
 /// An iterator over the ATAGS on this system.
 pub struct Atags {
-    ptr: &'static raw::Atag,
+    ptr: *const raw::Atag,
 }
 
 impl Atags {
     /// Returns an instance of `Atags`, an iterator over ATAGS on this system.
     pub fn get() -> Atags {
         Atags {
-            ptr: unsafe { &*(ATAG_BASE as *const raw::Atag) }
+            ptr: ATAG_BASE as *const raw::Atag,
         }
     }
 }
@@ -24,6 +25,22 @@ impl Iterator for Atags {
     type Item = Atag;
 
     fn next(&mut self) -> Option<Atag> {
-        unimplemented!("atags iterator")
+        match unsafe { self.ptr.as_ref() } {
+            Some(ptr) => {
+                let atag = unsafe { &*self.ptr };
+                match atag.next() {
+                    Some(next_atag) => {
+                        let result = ptr.into();
+                        self.ptr = next_atag;
+                        Some(result)
+                    }
+                    None => {
+                        self.ptr = ptr::null();
+                        Some(ptr.into())
+                    }
+                }
+            }
+            None => None,
+        }
     }
 }
diff --git a/pi/src/atags/raw.rs b/pi/src/atags/raw.rs
index 19162c3..2558f62 100644
--- a/pi/src/atags/raw.rs
+++ b/pi/src/atags/raw.rs
@@ -3,7 +3,7 @@
 pub struct Atag {
     pub dwords: u32,
     pub tag: u32,
-    pub kind: Kind
+    pub kind: Kind,
 }
 
 impl Atag {
@@ -20,7 +20,15 @@ impl Atag {
 
     /// Returns the ATAG following `self`, if there is one.
     pub fn next(&self) -> Option<&Atag> {
-        unimplemented!()
+        unsafe {
+            let addr = ((self) as *const Atag) as *const u8;
+            let next_atag = addr.offset(4 * self.dwords as isize) as *mut Atag;
+
+            match (*next_atag).tag {
+                super::raw::Atag::NONE => None,
+                _ => next_atag.as_ref(),
+            }
+        }
     }
 }
 
@@ -29,7 +37,7 @@ impl Atag {
 pub union Kind {
     pub core: Core,
     pub mem: Mem,
-    pub cmd: Cmd
+    pub cmd: Cmd,
 }
 
 /// A `CORE` ATAG.
@@ -38,7 +46,7 @@ pub union Kind {
 pub struct Core {
     pub flags: u32,
     pub page_size: u32,
-    pub root_dev: u32
+    pub root_dev: u32,
 }
 
 /// A `MEM` ATAG.
@@ -46,7 +54,7 @@ pub struct Core {
 #[derive(Debug, Copy, Clone)]
 pub struct Mem {
     pub size: u32,
-    pub start: u32
+    pub start: u32,
 }
 
 /// A `CMDLINE` ATAG.
@@ -54,5 +62,5 @@ pub struct Mem {
 #[derive(Debug, Copy, Clone)]
 pub struct Cmd {
     /// The first byte of the command line string.
-    pub cmd: u8
+    pub cmd: u8,
 }
diff --git a/pi/src/gpio.rs b/pi/src/gpio.rs
index f70bfb5..f914de1 100644
--- a/pi/src/gpio.rs
+++ b/pi/src/gpio.rs
@@ -102,7 +102,8 @@ impl Gpio<Uninitialized> {
     /// Enables the alternative function `function` for `self`. Consumes self
     /// and returns a `Gpio` structure in the `Alt` state.
     pub fn into_alt(self, function: Function) -> Gpio<Alt> {
-        unimplemented!()
+        self.registers.FSEL[(self.pin / 10) as usize].or_mask((function as u32) << (3 * (self.pin % 10)));
+        self.transition()
     }
 
     /// Sets this pin to be an _output_ pin. Consumes self and returns a `Gpio`
@@ -121,12 +122,12 @@ impl Gpio<Uninitialized> {
 impl Gpio<Output> {
     /// Sets (turns on) the pin.
     pub fn set(&mut self) {
-        unimplemented!()
+        self.registers.SET[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 
     /// Clears (turns off) the pin.
     pub fn clear(&mut self) {
-        unimplemented!()
+        self.registers.CLR[(self.pin / 32) as usize].write(1 << (self.pin % 32));
     }
 }
 
@@ -134,6 +135,6 @@ impl Gpio<Input> {
     /// Reads the pin's value. Returns `true` if the level is high and `false`
     /// if the level is low.
     pub fn level(&mut self) -> bool {
-        unimplemented!()
+        self.registers.LEV[(self.pin / 32) as usize].has_mask(1 << (self.pin % 32))
     }
 }
diff --git a/pi/src/lib.rs b/pi/src/lib.rs
index e6c8952..87b0252 100644
--- a/pi/src/lib.rs
+++ b/pi/src/lib.rs
@@ -2,7 +2,6 @@
 #![feature(const_fn)]
 #![feature(asm)]
 #![feature(decl_macro)]
-#![feature(repr_align)]
 #![feature(attr_literals)]
 #![feature(never_type)]
 #![feature(pointer_methods)]
diff --git a/pi/src/timer.rs b/pi/src/timer.rs
index e0aa184..db60af2 100644
--- a/pi/src/timer.rs
+++ b/pi/src/timer.rs
@@ -30,21 +30,29 @@ impl Timer {
     /// Reads the system timer's counter and returns the 64-bit counter value.
     /// The returned value is the number of elapsed microseconds.
     pub fn read(&self) -> u64 {
-        unimplemented!()
+        let low = self.registers.CLO.read();
+        let high = self.registers.CHI.read();
+        ((high as u64) << 32) | (low as u64)
     }
 }
 
 /// Returns the current time in microseconds.
 pub fn current_time() -> u64 {
-    unimplemented!()
+    Timer::new().read()
 }
 
 /// Spins until `us` microseconds have passed.
 pub fn spin_sleep_us(us: u64) {
-    unimplemented!()
+    let old = current_time();
+    loop {
+        let new = current_time();
+        if old + us <= new {
+            break;
+        }
+    }
 }
 
 /// Spins until `ms` milliseconds have passed.
 pub fn spin_sleep_ms(ms: u64) {
-    unimplemented!()
+    spin_sleep_us(ms * 1000);
 }
diff --git a/pi/src/uart.rs b/pi/src/uart.rs
index 92b6159..4d00b59 100644
--- a/pi/src/uart.rs
+++ b/pi/src/uart.rs
@@ -24,6 +24,26 @@ enum LsrStatus {
 #[allow(non_snake_case)]
 struct Registers {
     // FIXME: Declare the "MU" registers from page 8.
+    AUX_MU_IO_REG: Volatile<u8>,
+    __r0: [Reserved<u8>; 3],
+    AUX_MU_IER_REG: Volatile<u8>,
+    __r1: [Reserved<u8>; 3],
+    AUX_MU_IIR_REG: Volatile<u8>,
+    __r2: [Reserved<u8>; 3],
+    AUX_MU_LCR_REG: Volatile<u8>,
+    __r3: [Reserved<u8>; 3],
+    AUX_MU_MCR_REG: Volatile<u8>,
+    __r4: [Reserved<u8>; 3],
+    AUX_MU_LSR_REG: ReadVolatile<u8>,
+    __r5: [Reserved<u8>; 3],
+    AUX_MU_MSR_REG: ReadVolatile<u8>,
+    __r6: [Reserved<u8>; 3],
+    AUX_MU_SCRATCH: Volatile<u8>,
+    __r7: [Reserved<u8>; 3],
+    AUX_MU_CNTL_REG: Volatile<u8>,
+    __r8: [Reserved<u8>; 3],
+    AUX_MU_STAT_REG: ReadVolatile<u32>,
+    AUX_MU_BAUD: Volatile<u16>
 }
 
 /// The Raspberry Pi's "mini UART".
@@ -46,27 +66,41 @@ impl MiniUart {
             (*AUX_ENABLES).or_mask(1);
             &mut *(MU_REG_BASE as *mut Registers)
         };
-
+        
         // FIXME: Implement remaining mini UART initialization.
-        unimplemented!()
+        // GPIO 14 15 set to TX/RX
+        Gpio::new(14).into_alt(Function::Alt5);
+        Gpio::new(15).into_alt(Function::Alt5);
+        registers.AUX_MU_LCR_REG.or_mask(0b11); // 8-bit data size
+        // baudrate = system_clock_freq / (8 * (baud_reg + 1))
+        // system_clock_freq is 250MHz (Page 10)
+        // 250MHz / 8 / 115200 - 1 = 270
+        registers.AUX_MU_BAUD.write(270); // 16-bit baudrate register
+        registers.AUX_MU_CNTL_REG.or_mask(0b11); // enable TX & RX
+
+        MiniUart {
+            registers: registers,
+            timeout: None,
+        }
     }
 
     /// Set the read timeout to `milliseconds` milliseconds.
     pub fn set_read_timeout(&mut self, milliseconds: u32) {
-        unimplemented!()
+        self.timeout = Some(milliseconds)
     }
 
     /// Write the byte `byte`. This method blocks until there is space available
     /// in the output FIFO.
     pub fn write_byte(&mut self, byte: u8) {
-        unimplemented!()
+        while !self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::TxAvailable as u8) { };
+        self.registers.AUX_MU_IO_REG.write(byte);
     }
 
     /// Returns `true` if there is at least one byte ready to be read. If this
     /// method returns `true`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately. This method does not block.
     pub fn has_byte(&self) -> bool {
-        unimplemented!()
+        self.registers.AUX_MU_LSR_REG.has_mask(LsrStatus::DataReady as u8)
     }
 
     /// Blocks until there is a byte ready to read. If a read timeout is set,
@@ -78,17 +112,50 @@ impl MiniUart {
     /// returns `Ok(())`, a subsequent call to `read_byte` is guaranteed to
     /// return immediately.
     pub fn wait_for_byte(&self) -> Result<(), ()> {
-        unimplemented!()
+        match self.timeout {
+            None => {
+                loop {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+            },
+            Some(timeout) => {
+                let old = timer::current_time();
+                let deadline = old + (timeout as u64) * 1000; // Internal clock unit is microsecond, but timeout unit is millisecond
+                while deadline >= timer::current_time() {
+                    if self.has_byte() {
+                        return Ok(())
+                    }
+                }
+                Err(())
+            }
+        }
     }
 
     /// Reads a byte. Blocks indefinitely until a byte is ready to be read.
     pub fn read_byte(&mut self) -> u8 {
-        unimplemented!()
+        while !self.has_byte() { }
+        self.registers.AUX_MU_IO_REG.read()
     }
 }
 
 // FIXME: Implement `fmt::Write` for `MiniUart`. A b'\r' byte should be written
 // before writing any b'\n' byte.
+impl fmt::Write for MiniUart {
+    fn write_str(&mut self, s: &str) -> fmt::Result {
+        for byte in s.bytes() {
+            match byte {
+                b'\n' => {
+                    self.write_byte(b'\r');
+                    self.write_byte(b'\n');
+                },
+                _ => self.write_byte(byte)
+            }
+        }
+        Ok(())
+    }
+}
 
 #[cfg(feature = "std")]
 mod uart_io {
@@ -104,4 +171,34 @@ mod uart_io {
     //
     // The `io::Write::write()` method must write all of the requested bytes
     // before returning.
+    impl io::Read for MiniUart {
+       fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+           match self.wait_for_byte() {
+               Ok(()) => {
+                   let mut index = 0;
+                   while self.has_byte() && index < buf.len() {
+                       buf[index] = self.read_byte();
+                       index += 1;
+                   }
+                   Ok(index)
+               },
+               Err(()) => {
+                   Err(io::Error::new(io::ErrorKind::TimedOut, "reading UART timed out"))
+               }
+           }
+       }
+    }
+
+    impl io::Write for MiniUart {
+       fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+           for byte in buf {
+               self.write_byte(*byte);
+           }
+           Ok(buf.len())
+       }
+
+       fn flush(&mut self) -> io::Result<()> {
+           unimplemented!()
+       }
+    }
 }
diff --git a/std/src/collections/hash/map.rs b/std/src/collections/hash/map.rs
index 4114354..ca6c7c9 100644
--- a/std/src/collections/hash/map.rs
+++ b/std/src/collections/hash/map.rs
@@ -1972,7 +1972,7 @@ impl<'a, K, V> Placer<V> for Entry<'a, K, V> {
 #[unstable(feature = "collection_placement",
            reason = "placement protocol is subject to change",
            issue = "30172")]
-impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {
+unsafe impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {
     fn pointer(&mut self) -> *mut V {
         self.bucket.read_mut().1
     }
